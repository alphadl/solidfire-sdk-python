

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>solidfire &mdash; SolidFire Python SDK v1.1.0.85</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/solidfire.css" type="text/css" />
  

  
    <link rel="top" title="SolidFire Python SDK v1.1.0.85" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> solidfire-sdk-python
          

          
            
            <img src="../_static/PythonSDK.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.1.0.85
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../solidfire.html">solidfire package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">solidfire-sdk-python</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="index.html">Module code</a> &raquo;</li>
      
    <li>solidfire</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for solidfire</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Copyright &amp;copy; 2014-2016 NetApp, Inc. All Rights Reserved.</span>
<span class="c1">#</span>
<span class="c1"># DO NOT EDIT THIS CODE BY HAND! It has been generated with jsvcgen.</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">logging</span> <span class="k">import</span> <span class="n">Logger</span>
<span class="kn">from</span> <span class="nn">solidfire</span> <span class="k">import</span> <span class="n">common</span>
<span class="kn">from</span> <span class="nn">solidfire.adaptor</span> <span class="k">import</span> <span class="n">ElementServiceAdaptor</span>

<span class="kn">from</span> <span class="nn">solidfire.common</span> <span class="k">import</span> <span class="n">ServiceBase</span><span class="p">,</span> <span class="n">ApiVersionExceededError</span><span class="p">,</span> \
    <span class="n">ApiVersionUnsupportedError</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddClusterAdminResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddDrivesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddLdapClusterAdminResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddNodesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AddVirtualNetworkResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">AsyncHandleResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ClearClusterFaultsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CloneMultipleVolumesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CloneVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CompleteClusterPairingResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CompleteVolumePairingResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateBackupTargetResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateGroupSnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateScheduleResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateSnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateVolumeAccessGroupResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">CreateVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DeleteGroupSnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DeleteSnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DeleteVolumeAccessGroupResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DeleteVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DisableEncryptionAtRestResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DisableLdapAuthenticationResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">DisableSnmpResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">EnableEncryptionAtRestResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">EnableLdapAuthenticationResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">EnableSnmpResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetAPIResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetAsyncResultResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetBackupTargetResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterCapacityResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterFullThresholdResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterStatsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetClusterVersionInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetCurrentClusterAdminResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetDriveHardwareInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetDriveStatsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetEfficiencyResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetLdapConfigurationResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetLimitsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetNetworkConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetNodeStatsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetScheduleResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetSnmpACLResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetSnmpInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetSnmpStateResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetSnmpTrapInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetVolumeAccessGroupLunAssignmentsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetVolumeEfficiencyResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">GetVolumeStatsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListAccountsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListActiveNodesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListActivePairedVolumesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListActiveVolumesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListAllNodesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListBackupTargetsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListBulkVolumeJobsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListClusterAdminsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListClusterFaultsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListClusterPairsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListDeletedVolumesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListDriveHardwareResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListDrivesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListEventsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListFibreChannelPortInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListFibreChannelSessionsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListGroupSnapshotsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListISCSISessionsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListNodeFibreChannelPortInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListNodeStatsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListPendingNodesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListSchedulesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListSnapshotsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListTestsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListUtilitiesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVirtualNetworksResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumeAccessGroupsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumeStatsByAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumeStatsByVolumeAccessGroupResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumeStatsByVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumesForAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ListVolumesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyBackupTargetResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyClusterAdminResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyClusterFullThresholdResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyGroupSnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyScheduleResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifySnapshotResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyVolumeAccessGroupLunAssignmentsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyVolumeAccessGroupResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyVolumePairResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ModifyVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">PurgeDeletedVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveAccountResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveBackupTargetResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveClusterAdminResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveClusterPairResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveNodesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveVirtualNetworkResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RemoveVolumePairResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">ResetDrivesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">RestoreDeletedVolumeResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetClusterConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetNetworkConfigResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetSnmpACLResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetSnmpInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SetSnmpTrapInfoResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">SnmpSendTestTrapsResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">StartBulkVolumeReadResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">StartBulkVolumeWriteResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">StartClusterPairingResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">StartVolumePairingResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestConnectEnsembleResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestConnectMvipResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestConnectSvipResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestDrivesResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestLdapAuthenticationResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">TestPingResult</span>
<span class="kn">from</span> <span class="nn">solidfire.results</span> <span class="k">import</span> <span class="n">UpdateBulkVolumeStatusResult</span>

<span class="n">OPTIONAL</span> <span class="o">=</span> <span class="kc">None</span>


<div class="viewcode-block" id="Element"><a class="viewcode-back" href="../solidfire.html#solidfire.Element">[docs]</a><span class="k">class</span> <span class="nc">Element</span><span class="p">(</span><span class="n">ServiceBase</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The API for controlling a SolidFire cluster.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mvip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">api_version</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">verify_ssl</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor for initializing a connection to an instance of Element OS</span>

<span class="sd">        :param mvip: the management IP (IP or hostname)</span>
<span class="sd">        :type mvip: str</span>
<span class="sd">        :param username: username use to connect to the Element OS instance.</span>
<span class="sd">        :type username: str</span>
<span class="sd">        :param password: authentication for username</span>
<span class="sd">        :type password: str</span>
<span class="sd">        :param api_version: specific version of Element OS to connect</span>
<span class="sd">        :type api_version: float or str</span>
<span class="sd">        :param verify_ssl: disable to avoid ssl connection errors especially</span>
<span class="sd">            when using an IP instead of a hostname</span>
<span class="sd">        :type verify_ssl: bool</span>
<span class="sd">        :param dispatcher: a prebuilt or custom http dispatcher</span>
<span class="sd">        :return: a configured and tested instance of Element</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ServiceBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mvip</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">,</span> <span class="n">api_version</span><span class="p">,</span>
                             <span class="n">verify_ssl</span><span class="p">,</span> <span class="n">dispatcher</span><span class="p">)</span>

<div class="viewcode-block" id="Element.add_account"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_account">[docs]</a>    <span class="k">def</span> <span class="nf">add_account</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">username</span><span class="p">,</span>
            <span class="n">initiator_secret</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">target_secret</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to add a new account to the system.</span>
<span class="sd">        New volumes can be created under the new account.</span>
<span class="sd">        The CHAP settings specified for the account applies to all volumes</span>
<span class="sd">        owned by the account.</span>

<span class="sd">        :param username: [required] Unique username for this account. (May be 1</span>
<span class="sd">            to 64 characters in length).</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :param initiator_secret: (optional) CHAP secret to use for the</span>
<span class="sd">            initiator. Should be 12-16 characters long and impenetrable. The</span>
<span class="sd">            CHAP initiator secrets must be unique and cannot be the same as the</span>
<span class="sd">            target CHAP secret.</span>

<span class="sd">            If not specified, a random secret is created.</span>

<span class="sd">        :type initiator_secret: CHAPSecret</span>

<span class="sd">        :param target_secret: (optional) CHAP secret to use for the target</span>
<span class="sd">            (mutual CHAP authentication). Should be 12-16 characters long and</span>
<span class="sd">            impenetrable. The CHAP target secrets must be unique and cannot be</span>
<span class="sd">            the same as the initiator CHAP secret.</span>

<span class="sd">            If not specified, a random secret is created.</span>

<span class="sd">        :type target_secret: CHAPSecret</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">initiator_secret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;initiatorSecret&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initiator_secret</span>
        <span class="k">if</span> <span class="n">target_secret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;targetSecret&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_secret</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddAccount&#39;</span><span class="p">,</span>
            <span class="n">AddAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_account_by_id"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_account_by_id">[docs]</a>    <span class="k">def</span> <span class="nf">get_account_by_id</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns details about an account, given its AccountID.</span>

<span class="sd">        :param account_id: [required] Specifies the account for which details</span>
<span class="sd">            are gathered.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetAccountByID&#39;</span><span class="p">,</span>
            <span class="n">GetAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_account_by_name"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_account_by_name">[docs]</a>    <span class="k">def</span> <span class="nf">get_account_by_name</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">username</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns details about an account, given its Username.</span>

<span class="sd">        :param username: [required] Username for the account.</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetAccountByName&#39;</span><span class="p">,</span>
            <span class="n">GetAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_accounts"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_accounts">[docs]</a>    <span class="k">def</span> <span class="nf">list_accounts</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_account_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the entire list of accounts, with optional paging support.</span>

<span class="sd">        :param start_account_id: (optional) Starting *account_id* to return. If</span>
<span class="sd">            no Account exists with this *account_id,* the next Account by</span>
<span class="sd">            *account_id* order is used as the start of the list. To page</span>
<span class="sd">            through the list, pass the *account_id* of the last Account in the</span>
<span class="sd">            previous response + 1</span>
<span class="sd">        :type start_account_id: int</span>

<span class="sd">        :param limit: (optional) Maximum number of *account_info* objects to</span>
<span class="sd">            return.</span>
<span class="sd">        :type limit: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListAccountsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">start_account_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startAccountID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_account_id</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListAccounts&#39;</span><span class="p">,</span>
            <span class="n">ListAccountsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_account"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_account">[docs]</a>    <span class="k">def</span> <span class="nf">modify_account</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,</span>
            <span class="n">username</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">status</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">initiator_secret</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">target_secret</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to modify an existing account.</span>
<span class="sd">        When locking an account, any existing connections from that account are</span>
<span class="sd">        immediately terminated.</span>
<span class="sd">        When changing CHAP settings, any existing connections continue to be</span>
<span class="sd">        active,</span>
<span class="sd">        and the new CHAP values are only used on subsequent connection or</span>
<span class="sd">        reconnection.</span>

<span class="sd">        :param account_id: [required] *account_id* for the account to modify.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :param username: (optional) Change the username of the account to this</span>
<span class="sd">            value.</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :param status: (optional) Status of the account.</span>
<span class="sd">        :type status: str</span>

<span class="sd">        :param initiator_secret: (optional) CHAP secret to use for the</span>
<span class="sd">            initiator. Should be 12-16 characters long and impenetrable.</span>
<span class="sd">        :type initiator_secret: CHAPSecret</span>

<span class="sd">        :param target_secret: (optional) CHAP secret to use for the target</span>
<span class="sd">            (mutual CHAP authentication). Should be 12-16 characters long and</span>
<span class="sd">            impenetrable.</span>
<span class="sd">        :type target_secret: CHAPSecret</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">username</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;username&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">username</span>
        <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;status&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">status</span>
        <span class="k">if</span> <span class="n">initiator_secret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;initiatorSecret&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initiator_secret</span>
        <span class="k">if</span> <span class="n">target_secret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;targetSecret&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_secret</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyAccount&#39;</span><span class="p">,</span>
            <span class="n">ModifyAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_account"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_account">[docs]</a>    <span class="k">def</span> <span class="nf">remove_account</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to remove an existing account.</span>
<span class="sd">        All Volumes must be deleted and purged on the account before it can be</span>
<span class="sd">        removed.</span>
<span class="sd">        If volumes on the account are still pending deletion, *remove_account*</span>
<span class="sd">        cannot be used until *delete_volume* to delete and purge the volumes.</span>

<span class="sd">        :param account_id: [required] *account_id* for the account to remove.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveAccount&#39;</span><span class="p">,</span>
            <span class="n">RemoveAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_account_efficiency"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_account_efficiency">[docs]</a>    <span class="k">def</span> <span class="nf">get_account_efficiency</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,</span>
            <span class="n">force</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_account_efficiency* is used to retrieve information about a volume</span>
<span class="sd">        account. Only the account given as a parameter in this API method is</span>
<span class="sd">        used to compute the capacity.</span>

<span class="sd">        :param account_id: [required] Specifies the volume account for which</span>
<span class="sd">            capacity is computed.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :param force: (optional)</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetEfficiencyResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;force&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">force</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetAccountEfficiency&#39;</span><span class="p">,</span>
            <span class="n">GetEfficiencyResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_backup_target"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_backup_target">[docs]</a>    <span class="k">def</span> <span class="nf">create_backup_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *create_backup_target* allows you to create and store backup target</span>
<span class="sd">        information so that you do not need to re-enter it each time a backup</span>
<span class="sd">        is created.</span>

<span class="sd">        :param name: [required] Name for the backup target.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateBackupTargetResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CreateBackupTarget&#39;</span><span class="p">,</span>
            <span class="n">CreateBackupTargetResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_backup_target"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_backup_target">[docs]</a>    <span class="k">def</span> <span class="nf">get_backup_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">backup_target_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_backup_target* allows you to return information about a specific</span>
<span class="sd">        backup target that has been created.</span>

<span class="sd">        :param backup_target_id: [required] Unique identifier assigned to the</span>
<span class="sd">            backup target.</span>
<span class="sd">        :type backup_target_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetBackupTargetResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;backupTargetID&quot;</span><span class="p">:</span> <span class="n">backup_target_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetBackupTarget&#39;</span><span class="p">,</span>
            <span class="n">GetBackupTargetResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_backup_targets"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_backup_targets">[docs]</a>    <span class="k">def</span> <span class="nf">list_backup_targets</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use *list_backup_targets* to retrieve information about all</span>
<span class="sd">        backup targets that have been created.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListBackupTargetsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListBackupTargets&#39;</span><span class="p">,</span>
            <span class="n">ListBackupTargetsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_backup_target"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_backup_target">[docs]</a>    <span class="k">def</span> <span class="nf">modify_backup_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">backup_target_id</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_backup_target* is used to change attributes of a backup target.</span>

<span class="sd">        :param backup_target_id: [required] Unique identifier assigned to the</span>
<span class="sd">            backup target.</span>
<span class="sd">        :type backup_target_id: int</span>

<span class="sd">        :param name: (optional) Name for the backup target.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyBackupTargetResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;backupTargetID&quot;</span><span class="p">:</span> <span class="n">backup_target_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyBackupTarget&#39;</span><span class="p">,</span>
            <span class="n">ModifyBackupTargetResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_backup_target"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_backup_target">[docs]</a>    <span class="k">def</span> <span class="nf">remove_backup_target</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">backup_target_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *remove_backup_target* allows you to delete backup targets.</span>

<span class="sd">        :param backup_target_id: [required] Unique target ID of the target to</span>
<span class="sd">            remove.</span>
<span class="sd">        :type backup_target_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveBackupTargetResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;backupTargetID&quot;</span><span class="p">:</span> <span class="n">backup_target_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveBackupTarget&#39;</span><span class="p">,</span>
            <span class="n">RemoveBackupTargetResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_capacity"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_capacity">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_capacity</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the high-level capacity measurements for an entire cluster.</span>
<span class="sd">        The fields returned from this method can be used to calculate the</span>
<span class="sd">        efficiency rates that are displayed in the Element User Interface.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterCapacityResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterCapacity&#39;</span><span class="p">,</span>
            <span class="n">GetClusterCapacityResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return configuration information about the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterInfo&#39;</span><span class="p">,</span>
            <span class="n">GetClusterInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_version_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_version_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_version_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return information about the Element software version running on each</span>
<span class="sd">        node in the cluster.</span>
<span class="sd">        Information about the nodes that are currently in the process of</span>
<span class="sd">        upgrading software is also returned.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterVersionInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterVersionInfo&#39;</span><span class="p">,</span>
            <span class="n">GetClusterVersionInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_limits"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_limits">[docs]</a>    <span class="k">def</span> <span class="nf">get_limits</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the limit values set by the API</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetLimitsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetLimits&#39;</span><span class="p">,</span>
            <span class="n">GetLimitsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_events"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_events">[docs]</a>    <span class="k">def</span> <span class="nf">list_events</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">max_events</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">start_event_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">end_event_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">event_queue_type</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_events* returns events detected on the cluster, sorted from</span>
<span class="sd">        oldest to newest.</span>

<span class="sd">        :param max_events: (optional) Specifies the maximum number of events to</span>
<span class="sd">            return.</span>
<span class="sd">        :type max_events: int</span>

<span class="sd">        :param start_event_id: (optional) Identifies the beginning of a range</span>
<span class="sd">            of events to return.</span>
<span class="sd">        :type start_event_id: int</span>

<span class="sd">        :param end_event_id: (optional) Identifies the end of a range of events</span>
<span class="sd">            to return.</span>
<span class="sd">        :type end_event_id: int</span>

<span class="sd">        :param event_queue_type: (optional)</span>
<span class="sd">        :type event_queue_type: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListEventsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;list_events&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;event_queue_type&quot;</span><span class="p">,</span>
                 <span class="n">event_queue_type</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">max_events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;maxEvents&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_events</span>
        <span class="k">if</span> <span class="n">start_event_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startEventID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_event_id</span>
        <span class="k">if</span> <span class="n">end_event_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;endEventID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_event_id</span>
        <span class="k">if</span> <span class="n">event_queue_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;eventQueueType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">event_queue_type</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListEvents&#39;</span><span class="p">,</span>
            <span class="n">ListEventsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_cluster_faults"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_cluster_faults">[docs]</a>    <span class="k">def</span> <span class="nf">list_cluster_faults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">exceptions</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">best_practices</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">update</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">fault_types</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_cluster_faults* is used to retrieve information about any faults</span>
<span class="sd">        detected on the cluster.</span>
<span class="sd">        With this method, both current and resolved faults can be retrieved.</span>
<span class="sd">        The system caches faults every 30 seconds.</span>

<span class="sd">        :param exceptions: (optional)</span>
<span class="sd">        :type exceptions: bool</span>

<span class="sd">        :param best_practices: (optional) Include faults triggered by</span>
<span class="sd">            sub-optimal system configuration. Possible values: true, false</span>
<span class="sd">        :type best_practices: bool</span>

<span class="sd">        :param update: (optional)</span>
<span class="sd">        :type update: bool</span>

<span class="sd">        :param fault_types: (optional) Determines the types of faults returned:</span>
<span class="sd">            current: List active, unresolved faults. **resolved**: List faults</span>
<span class="sd">            that were previously detected and resolved. **all**: (Default) List</span>
<span class="sd">            both current and resolved faults. You can see the fault status in</span>
<span class="sd">            the &#39;resolved&#39; field of the Cluster Fault object.</span>
<span class="sd">        :type fault_types: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListClusterFaultsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">exceptions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;exceptions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exceptions</span>
        <span class="k">if</span> <span class="n">best_practices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;bestPractices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_practices</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;update&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">update</span>
        <span class="k">if</span> <span class="n">fault_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;faultTypes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fault_types</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListClusterFaults&#39;</span><span class="p">,</span>
            <span class="n">ListClusterFaultsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.clear_cluster_faults"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.clear_cluster_faults">[docs]</a>    <span class="k">def</span> <span class="nf">clear_cluster_faults</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">fault_types</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *clear_cluster_faults* is used to clear information about both current</span>
<span class="sd">        faults that are resolved as well as faults that were previously</span>
<span class="sd">        detected and resolved can be cleared.</span>

<span class="sd">        :param fault_types: (optional) Determines the types of faults cleared:</span>

<span class="sd">            **current**: Faults that are currently detected and have not been</span>
<span class="sd">            resolved.</span>

<span class="sd">            **resolved**: Faults that were previously detected and resolved.</span>

<span class="sd">            **all**: Both current and resolved faults are cleared. The fault</span>
<span class="sd">            status can be determined by the \&quot;resolved\&quot; field of the fault</span>
<span class="sd">            object.</span>

<span class="sd">        :type fault_types: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ClearClusterFaultsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">fault_types</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;faultTypes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fault_types</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ClearClusterFaults&#39;</span><span class="p">,</span>
            <span class="n">ClearClusterFaultsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_config">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_cluster_config* API method is used to return information about</span>
<span class="sd">        the cluster configuration this node uses to communicate with the</span>
<span class="sd">        cluster it is a part of.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterConfig&#39;</span><span class="p">,</span>
            <span class="n">GetClusterConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_full_threshold"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_full_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_full_threshold</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_cluster_full_threshold* is used to view the stages set for cluster</span>
<span class="sd">        fullness levels. All levels are returned when this method is entered.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterFullThresholdResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterFullThreshold&#39;</span><span class="p">,</span>
            <span class="n">GetClusterFullThresholdResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_cluster_full_threshold"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_cluster_full_threshold">[docs]</a>    <span class="k">def</span> <span class="nf">modify_cluster_full_threshold</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">stage2_aware_threshold</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">stage3_block_threshold_percent</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">max_metadata_over_provision_factor</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_cluster_full_threshold* is used to change the level at which an</span>
<span class="sd">        event is generated when the storage cluster approaches the capacity</span>
<span class="sd">        utilization requested. The number entered in this setting is used to</span>
<span class="sd">        indicate the number of node failures the system is required to recover</span>
<span class="sd">        from. For example, on a 10 node cluster, if you want to be alerted when</span>
<span class="sd">        the system cannot recover from 3 nodes failures, enter the value of</span>
<span class="sd">        \&quot;3\&quot;. When this number is reached, a message alert is sent to the</span>
<span class="sd">        Event Log in the Cluster Management Console.</span>

<span class="sd">        :param stage2_aware_threshold: (optional) Number of nodes worth of</span>
<span class="sd">            capacity remaining on the cluster that triggers a notification.</span>
<span class="sd">        :type stage2_aware_threshold: int</span>

<span class="sd">        :param stage3_block_threshold_percent: (optional) Percent below</span>
<span class="sd">            \&quot;Error\&quot; state to raise a cluster \&quot;Warning\&quot; alert.</span>
<span class="sd">        :type stage3_block_threshold_percent: int</span>

<span class="sd">        :param max_metadata_over_provision_factor: (optional) A value</span>
<span class="sd">            representative of the number of times metadata space can be over</span>
<span class="sd">            provisioned relative to the amount of space available. For example,</span>
<span class="sd">            if there was enough metadata space to store 100 *ti_b* of volumes</span>
<span class="sd">            and this number was set to 5, then 500 *ti_b* worth of volumes</span>
<span class="sd">            could be created.</span>
<span class="sd">        :type max_metadata_over_provision_factor: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyClusterFullThresholdResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;modify_cluster_full_threshold&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;stage3_block_threshold_percent&quot;</span><span class="p">,</span>
                 <span class="n">stage3_block_threshold_percent</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">stage2_aware_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;stage2AwareThreshold&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stage2_aware_threshold</span>
        <span class="k">if</span> <span class="n">stage3_block_threshold_percent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;stage3BlockThresholdPercent&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">stage3_block_threshold_percent</span>
        <span class="k">if</span> <span class="n">max_metadata_over_provision_factor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;maxMetadataOverProvisionFactor&quot;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">max_metadata_over_provision_factor</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyClusterFullThreshold&#39;</span><span class="p">,</span>
            <span class="n">ModifyClusterFullThresholdResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_cluster_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_cluster_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_cluster_stats* is used to return high-level activity measurements</span>
<span class="sd">        for the cluster. Values returned are cumulative from the creation of</span>
<span class="sd">        the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetClusterStatsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetClusterStats&#39;</span><span class="p">,</span>
            <span class="n">GetClusterStatsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_cluster_admins"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_cluster_admins">[docs]</a>    <span class="k">def</span> <span class="nf">list_cluster_admins</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_cluster_admins* returns the list of all cluster administrators</span>
<span class="sd">        for the cluster. There can be several cluster administrators that have</span>
<span class="sd">        different levels of permissions. There can be only one primary cluster</span>
<span class="sd">        administrator in the system. The primary Cluster Admin is the</span>
<span class="sd">        administrator that was created when the cluster was created. LDAP</span>
<span class="sd">        administrators can also be created when setting up an LDAP system on</span>
<span class="sd">        the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListClusterAdminsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListClusterAdmins&#39;</span><span class="p">,</span>
            <span class="n">ListClusterAdminsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_cluster_admin"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_cluster_admin">[docs]</a>    <span class="k">def</span> <span class="nf">add_cluster_admin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">username</span><span class="p">,</span>
            <span class="n">password</span><span class="p">,</span>
            <span class="n">access</span><span class="p">,</span>
            <span class="n">accept_eula</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *add_cluster_admin* adds a new Cluster Admin. A Cluster Admin can be</span>
<span class="sd">        used to manage the cluster via the API and management tools. Cluster</span>
<span class="sd">        Admins are completely separate and unrelated to standard tenant</span>
<span class="sd">        accounts.</span>




<span class="sd">        Each Cluster Admin can be restricted to a sub-set of the API. SolidFire</span>
<span class="sd">        recommends using multiple Cluster Admins for different users and</span>
<span class="sd">        applications. Each Cluster Admin should be given the minimal</span>
<span class="sd">        permissions necessary to reduce the potential impact of credential</span>
<span class="sd">        compromise.</span>

<span class="sd">        :param username: [required] Unique username for this Cluster Admin.</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :param password: [required] Password used to authenticate this Cluster</span>
<span class="sd">            Admin.</span>
<span class="sd">        :type password: str</span>

<span class="sd">        :param access: [required] Controls which methods this Cluster Admin can</span>
<span class="sd">            use. For more details on the levels of access, see \&quot;Access</span>
<span class="sd">            Control\&quot; in the Element API Guide.</span>
<span class="sd">        :type access: str[]</span>

<span class="sd">        :param accept_eula: (optional) Indicate your acceptance of the End User</span>
<span class="sd">            License Agreement when creating this cluster admin. To accept the</span>
<span class="sd">            EULA, set this parameter to true.</span>
<span class="sd">        :type accept_eula: bool</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddClusterAdminResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="n">password</span><span class="p">,</span>
            <span class="s2">&quot;access&quot;</span><span class="p">:</span> <span class="n">access</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;add_cluster_admin&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;accept_eula&quot;</span><span class="p">,</span>
                 <span class="n">accept_eula</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">accept_eula</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;acceptEula&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">accept_eula</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddClusterAdmin&#39;</span><span class="p">,</span>
            <span class="n">AddClusterAdminResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_cluster_admin"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_cluster_admin">[docs]</a>    <span class="k">def</span> <span class="nf">modify_cluster_admin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster_admin_id</span><span class="p">,</span>
            <span class="n">password</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">access</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_cluster_admin* is used to change the settings for a Cluster</span>
<span class="sd">        Admin or LDAP Cluster Admin. Access for the administrator Cluster Admin</span>
<span class="sd">        account cannot be changed.</span>

<span class="sd">        :param cluster_admin_id: [required] *cluster_admin_id* for the Cluster</span>
<span class="sd">            Admin or LDAP Cluster Admin to modify.</span>
<span class="sd">        :type cluster_admin_id: int</span>

<span class="sd">        :param password: (optional) Password used to authenticate this Cluster</span>
<span class="sd">            Admin.</span>
<span class="sd">        :type password: str</span>

<span class="sd">        :param access: (optional) Controls which methods this Cluster Admin can</span>
<span class="sd">            use. For more details on the levels of access, see \&quot;Access</span>
<span class="sd">            Control\&quot; in the Element API Guide.</span>
<span class="sd">        :type access: str[]</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyClusterAdminResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;clusterAdminID&quot;</span><span class="p">:</span> <span class="n">cluster_admin_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">password</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;password&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">password</span>
        <span class="k">if</span> <span class="n">access</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;access&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyClusterAdmin&#39;</span><span class="p">,</span>
            <span class="n">ModifyClusterAdminResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_cluster_admin"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_cluster_admin">[docs]</a>    <span class="k">def</span> <span class="nf">remove_cluster_admin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster_admin_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *remove_cluster_admin* is used to remove a Cluster Admin. The \&quot;admin\&quot;</span>
<span class="sd">        Cluster Admin cannot be removed.</span>

<span class="sd">        :param cluster_admin_id: [required] *cluster_admin_id* for the Cluster</span>
<span class="sd">            Admin to remove.</span>
<span class="sd">        :type cluster_admin_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveClusterAdminResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;clusterAdminID&quot;</span><span class="p">:</span> <span class="n">cluster_admin_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveClusterAdmin&#39;</span><span class="p">,</span>
            <span class="n">RemoveClusterAdminResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_cluster_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_cluster_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_cluster_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *set_cluster_config* API method is used to set the configuration</span>
<span class="sd">        this node uses to communicate with the cluster it is associated with.</span>
<span class="sd">        To see the states in which these objects can be modified see Cluster</span>
<span class="sd">        Object on page 109. To display the current cluster interface settings</span>
<span class="sd">        for a node, run the *get_cluster_config* API method.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :param cluster: [required] Objects that are changed for the cluster</span>
<span class="sd">            interface settings. Only the fields you want changed need to be</span>
<span class="sd">            added to this method as objects in the \&quot;cluster\&quot; parameter.</span>
<span class="sd">        :type cluster: ClusterConfig</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetClusterConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cluster&quot;</span><span class="p">:</span> <span class="n">cluster</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetClusterConfig&#39;</span><span class="p">,</span>
            <span class="n">SetClusterConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_snmp_acl"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_snmp_acl">[docs]</a>    <span class="k">def</span> <span class="nf">get_snmp_acl</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_snmp_acl* is used to return the current SNMP access permissions on</span>
<span class="sd">        the cluster nodes.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetSnmpACLResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetSnmpACL&#39;</span><span class="p">,</span>
            <span class="n">GetSnmpACLResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_snmp_acl"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_snmp_acl">[docs]</a>    <span class="k">def</span> <span class="nf">set_snmp_acl</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">networks</span><span class="p">,</span>
            <span class="n">usm_users</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *set_snmp_acl* is used to configure SNMP access permissions on the</span>
<span class="sd">        cluster nodes. The values set with this interface apply to all nodes in</span>
<span class="sd">        the cluster, and the values that are passed replace, in whole, all</span>
<span class="sd">        values set in any previous call to SetSnmpACL. Also note that the</span>
<span class="sd">        values set with this interface replace all \&quot;network\&quot; or</span>
<span class="sd">        *\&quot;usm_users\&quot;* values set with the older SetSnmpInfo.</span>

<span class="sd">        :param networks: [required] List of networks and what type of access</span>
<span class="sd">            they have to the SNMP servers running on the cluster nodes. See</span>
<span class="sd">            SNMP Network Object for possible \&quot;networks\&quot; values. REQUIRED if</span>
<span class="sd">            SNMP *v_* is disabled.</span>
<span class="sd">        :type networks: SnmpNetwork[]</span>

<span class="sd">        :param usm_users: [required] List of users and the type of access they</span>
<span class="sd">            have to the SNMP servers running on the cluster nodes. REQUIRED if</span>
<span class="sd">            SNMP v3 is enabled.</span>
<span class="sd">        :type usm_users: SnmpV3UsmUser[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetSnmpACLResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;networks&quot;</span><span class="p">:</span> <span class="n">networks</span><span class="p">,</span>
            <span class="s2">&quot;usmUsers&quot;</span><span class="p">:</span> <span class="n">usm_users</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetSnmpACL&#39;</span><span class="p">,</span>
            <span class="n">SetSnmpACLResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_snmp_trap_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_snmp_trap_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_snmp_trap_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_snmp_trap_info* is used to return current SNMP trap configuration</span>
<span class="sd">        information.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetSnmpTrapInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetSnmpTrapInfo&#39;</span><span class="p">,</span>
            <span class="n">GetSnmpTrapInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_snmp_trap_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_snmp_trap_info">[docs]</a>    <span class="k">def</span> <span class="nf">set_snmp_trap_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">trap_recipients</span><span class="p">,</span>
            <span class="n">cluster_fault_traps_enabled</span><span class="p">,</span>
            <span class="n">cluster_fault_resolved_traps_enabled</span><span class="p">,</span>
            <span class="n">cluster_event_traps_enabled</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *set_snmp_trap_info* is used to enable and disable the generation of</span>
<span class="sd">        SolidFire SNMP notifications (traps) and to specify the set of network</span>
<span class="sd">        host computers that are to receive the notifications. The values passed</span>
<span class="sd">        with each *set_snmp_trap_info* method replaces all values set in any</span>
<span class="sd">        previous method to SetSnmpTrapInfo.</span>

<span class="sd">        :param trap_recipients: [required] List of hosts that are to receive</span>
<span class="sd">            the traps generated by the Cluster Master. At least one object is</span>
<span class="sd">            required if any one of the trap types is enabled.</span>
<span class="sd">        :type trap_recipients: SnmpTrapRecipient[]</span>

<span class="sd">        :param cluster_fault_traps_enabled: [required] If \&quot;true\&quot;, when a</span>
<span class="sd">            cluster fault is logged a corresponding</span>
<span class="sd">            *solid_fire_cluster_fault_notification* is sent to the configured</span>
<span class="sd">            list of trap recipients.</span>
<span class="sd">        :type cluster_fault_traps_enabled: bool</span>

<span class="sd">        :param cluster_fault_resolved_traps_enabled: [required] If \&quot;true\&quot;,</span>
<span class="sd">            when a cluster fault is logged a corresponding</span>
<span class="sd">            *solid_fire_cluster_fault_resolved_notification* is sent to the</span>
<span class="sd">            configured list of trap recipients.</span>
<span class="sd">        :type cluster_fault_resolved_traps_enabled: bool</span>

<span class="sd">        :param cluster_event_traps_enabled: [required] If \&quot;true\&quot;, when a</span>
<span class="sd">            cluster fault is logged a corresponding</span>
<span class="sd">            *solid_fire_cluster_event_notification* is sent to the configured</span>
<span class="sd">            list of trap recipients.</span>
<span class="sd">        :type cluster_event_traps_enabled: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetSnmpTrapInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;trapRecipients&quot;</span><span class="p">:</span> <span class="n">trap_recipients</span><span class="p">,</span>
            <span class="s2">&quot;clusterFaultTrapsEnabled&quot;</span><span class="p">:</span> <span class="n">cluster_fault_traps_enabled</span><span class="p">,</span>
            <span class="s2">&quot;clusterFaultResolvedTrapsEnabled&quot;</span><span class="p">:</span>
                <span class="n">cluster_fault_resolved_traps_enabled</span><span class="p">,</span>
            <span class="s2">&quot;clusterEventTrapsEnabled&quot;</span><span class="p">:</span> <span class="n">cluster_event_traps_enabled</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetSnmpTrapInfo&#39;</span><span class="p">,</span>
            <span class="n">SetSnmpTrapInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.enable_snmp"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.enable_snmp">[docs]</a>    <span class="k">def</span> <span class="nf">enable_snmp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snmp_v3_enabled</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *enable_snmp* is used to enable SNMP on the cluster nodes. The values</span>
<span class="sd">        set with this interface apply to all nodes in the cluster, and the</span>
<span class="sd">        values that are passed replace, in whole, all values set in any</span>
<span class="sd">        previous call to EnableSnmp.</span>

<span class="sd">        :param snmp_v3_enabled: [required] If set to \&quot;true\&quot;, then SNMP v3 is</span>
<span class="sd">            enabled on each node in the cluster. If set to \&quot;false\&quot;, then SNMP</span>
<span class="sd">            v2 is enabled.</span>
<span class="sd">        :type snmp_v3_enabled: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: EnableSnmpResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;snmpV3Enabled&quot;</span><span class="p">:</span> <span class="n">snmp_v3_enabled</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;EnableSnmp&#39;</span><span class="p">,</span>
            <span class="n">EnableSnmpResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.disable_snmp"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.disable_snmp">[docs]</a>    <span class="k">def</span> <span class="nf">disable_snmp</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *disable_snmp* is used to disable SNMP on the cluster nodes.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DisableSnmpResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DisableSnmp&#39;</span><span class="p">,</span>
            <span class="n">DisableSnmpResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_snmp_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_snmp_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_snmp_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_snmp_info* is used to return the current simple network management</span>
<span class="sd">        protocol (SNMP) configuration information.</span>




<span class="sd">        **Note**: *get_snmp_info* will be available for Element OS 8 and prior</span>
<span class="sd">        releases. It will be deprecated after Element OS 8. There are two new</span>
<span class="sd">        SNMP API methods that you should migrate over to. They are</span>
<span class="sd">        *get_snmp_state* and GetSnmpACL. Please see details in this document</span>
<span class="sd">        for their descriptions and usage.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetSnmpInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetSnmpInfo&#39;</span><span class="p">,</span>
            <span class="n">GetSnmpInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_snmp_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_snmp_info">[docs]</a>    <span class="k">def</span> <span class="nf">set_snmp_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">networks</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">enabled</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">snmp_v3_enabled</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">usm_users</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *set_snmp_info* is used to configure SNMP v2 and v3 on the cluster</span>
<span class="sd">        nodes. The values set with this interface apply to all nodes in the</span>
<span class="sd">        cluster, and the values that are passed replace, in whole, all values</span>
<span class="sd">        set in any previous call to SetSnmpInfo.</span>




<span class="sd">        **Note**: *enable_snmp* and *set_snmp_acl* methods can be used to</span>
<span class="sd">        accomplish the same results as SetSnmpInfo. *set_snmp_info* will no</span>
<span class="sd">        longer be available after the Element 8 release. Please use</span>
<span class="sd">        *enable_snmp* and *set_snmp_acl* in the future.</span>

<span class="sd">        :param networks: (optional) List of networks and what type of access</span>
<span class="sd">            they have to the SNMP servers running on the cluster nodes. See</span>
<span class="sd">            SNMP Network Object for possible \&quot;networks\&quot; values. SNMP v2 only.</span>
<span class="sd">        :type networks: SnmpNetwork[]</span>

<span class="sd">        :param enabled: (optional) If set to \&quot;true\&quot;, then SNMP is enabled on</span>
<span class="sd">            each node in the cluster.</span>
<span class="sd">        :type enabled: bool</span>

<span class="sd">        :param snmp_v3_enabled: (optional) If set to \&quot;true\&quot;, then SNMP v3 is</span>
<span class="sd">            enabled on each node in the cluster.</span>
<span class="sd">        :type snmp_v3_enabled: bool</span>

<span class="sd">        :param usm_users: (optional) If SNMP v3 is enabled, this value must be</span>
<span class="sd">            passed in place of the \&quot;networks\&quot; parameter. SNMP v3 only.</span>
<span class="sd">        :type usm_users: SnmpV3UsmUser[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetSnmpInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">networks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;networks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">networks</span>
        <span class="k">if</span> <span class="n">enabled</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;enabled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enabled</span>
        <span class="k">if</span> <span class="n">snmp_v3_enabled</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;snmpV3Enabled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snmp_v3_enabled</span>
        <span class="k">if</span> <span class="n">usm_users</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;usmUsers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">usm_users</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetSnmpInfo&#39;</span><span class="p">,</span>
            <span class="n">SetSnmpInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_snmp_state"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_snmp_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_snmp_state</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_snmp_state* is used to return the current state of the SNMP</span>
<span class="sd">        feature.</span>




<span class="sd">        **Note**: *get_snmp_state* is new for Element OS 8. Please use this</span>
<span class="sd">        method and *set_snmp_acl* to migrate your SNMP functionality in the</span>
<span class="sd">        future.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetSnmpStateResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetSnmpState&#39;</span><span class="p">,</span>
            <span class="n">GetSnmpStateResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_api"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_api">[docs]</a>    <span class="k">def</span> <span class="nf">get_api</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the current version of the API and a list of all supported</span>
<span class="sd">        versions.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetAPIResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetAPI&#39;</span><span class="p">,</span>
            <span class="n">GetAPIResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_current_cluster_admin"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_current_cluster_admin">[docs]</a>    <span class="k">def</span> <span class="nf">get_current_cluster_admin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_current_cluster_admin* returns information for the current primary</span>
<span class="sd">        cluster administrator. The primary Cluster Admin was ncreated when the</span>
<span class="sd">        cluster was created.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetCurrentClusterAdminResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetCurrentClusterAdmin&#39;</span><span class="p">,</span>
            <span class="n">GetCurrentClusterAdminResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.enable_encryption_at_rest"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.enable_encryption_at_rest">[docs]</a>    <span class="k">def</span> <span class="nf">enable_encryption_at_rest</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *enable_encryption_at_rest* method is used to enable the Advanced</span>
<span class="sd">        Encryption Standard (AES) 256-bit encryption at rest on the cluster so</span>
<span class="sd">        that the cluster can manage the encryption key used for the drives on</span>
<span class="sd">        each node. This feature is not enabled by default. Enabling this</span>
<span class="sd">        operation allows the cluster to automatically manage encryption keys</span>
<span class="sd">        internally for the drives on each node in the cluster. Nodes do not</span>
<span class="sd">        store the keys to unlock drives and the keys are never passed over the</span>
<span class="sd">        network. Two nodes participating in a cluster are required to access</span>
<span class="sd">        the key to disable encryption on a drive. The encryption management</span>
<span class="sd">        does not affect performance or efficiency on the cluster. If an</span>
<span class="sd">        encryption-enabled drive or node is removed from the cluster with the</span>
<span class="sd">        API, all data is secure erased and any data left on the drive cannot be</span>
<span class="sd">        read or accessed.</span>
<span class="sd">        Enabling or disabling encryption should be performed when the cluster</span>
<span class="sd">        is running and in a healthy state. Encryption can be enabled or</span>
<span class="sd">        disabled at your discretion and can be performed as often as you need.</span>


<span class="sd">            **Note**: This process is asynchronous and returns a response</span>
<span class="sd">        before encryption is enabled. The *get_cluster_info* method can be used</span>
<span class="sd">        to poll the system to see when the process has completed.</span>


<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: EnableEncryptionAtRestResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;EnableEncryptionAtRest&#39;</span><span class="p">,</span>
            <span class="n">EnableEncryptionAtRestResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.disable_encryption_at_rest"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.disable_encryption_at_rest">[docs]</a>    <span class="k">def</span> <span class="nf">disable_encryption_at_rest</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *disable_encryption_at_rest* method enables you to remove the</span>
<span class="sd">        encryption that was previously applied to the cluster using the</span>
<span class="sd">        *enable_encryption_at_rest* method.</span>
<span class="sd">        This disable method is asynchronous and returns a response before</span>
<span class="sd">        encryption is disabled.</span>
<span class="sd">        You can use the *get_cluster_info* method to poll the system to see</span>
<span class="sd">        when the process has completed.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DisableEncryptionAtRestResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DisableEncryptionAtRest&#39;</span><span class="p">,</span>
            <span class="n">DisableEncryptionAtRestResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.snmp_send_test_traps"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.snmp_send_test_traps">[docs]</a>    <span class="k">def</span> <span class="nf">snmp_send_test_traps</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *snmp_send_test_traps* enables you to test SNMP functionality for a</span>
<span class="sd">        cluster. This method instructs the cluster to send test SNMP traps to</span>
<span class="sd">        the currently configured SNMP manager.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SnmpSendTestTrapsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SnmpSendTestTraps&#39;</span><span class="p">,</span>
            <span class="n">SnmpSendTestTrapsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_async_result"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_async_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_async_result</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">async_handle</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to retrieve the result of asynchronous method calls.</span>
<span class="sd">        Some method calls are long running and do not complete when the initial</span>
<span class="sd">        response is sent.</span>
<span class="sd">        To obtain the result of the method call, polling with</span>
<span class="sd">        *get_async_result* is required.</span>




<span class="sd">        *get_async_result* returns the overall status of the operation (in</span>
<span class="sd">        progress, completed, or error) in a standard fashion,</span>
<span class="sd">        but the actual data returned for the operation depends on the original</span>
<span class="sd">        method call and the return data is documented with each method.</span>




<span class="sd">        The result for a completed asynchronous method call can only be</span>
<span class="sd">        retrieved once.</span>
<span class="sd">        Once the final result has been returned, later attempts returns an</span>
<span class="sd">        error.</span>

<span class="sd">        :param async_handle: [required] A value that was returned from the</span>
<span class="sd">            original asynchronous method call.</span>
<span class="sd">        :type async_handle: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetAsyncResultResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;asyncHandle&quot;</span><span class="p">:</span> <span class="n">async_handle</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetAsyncResult&#39;</span><span class="p">,</span>
            <span class="n">GetAsyncResultResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_drives">[docs]</a>    <span class="k">def</span> <span class="nf">add_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drives</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *add_drives* is used to add one or more available drives to the cluster</span>
<span class="sd">        enabling the drives to host a portion of the cluster&#39;s data.</span>
<span class="sd">        When you add a node to the cluster or install new drives in an existing</span>
<span class="sd">        node, the new drives are marked as \&quot;available\&quot; and must be added via</span>
<span class="sd">        *add_drives* before they can be utilized.</span>
<span class="sd">        Use the *\&quot;list_drives\&quot;* method to display drives that are</span>
<span class="sd">        \&quot;available\&quot; to be added.</span>
<span class="sd">        When you add multiple drives, it is more efficient to add them in a</span>
<span class="sd">        single *\&quot;add_drives\&quot;* method call rather than multiple individual</span>
<span class="sd">        methods with a single drive each.</span>
<span class="sd">        This reduces the amount of data balancing that must occur to stabilize</span>
<span class="sd">        the storage load on the cluster.</span>




<span class="sd">        When you add a drive, the system automatically determines the \&quot;type\&quot;</span>
<span class="sd">        of drive it should be.</span>




<span class="sd">        The method returns immediately. However, it may take some time for the</span>
<span class="sd">        data in the cluster to be rebalanced using the newly added drives.</span>
<span class="sd">        As the new drive(s) are syncing on the system, you can use the</span>
<span class="sd">        *\&quot;list_sync_jobs\&quot;* method to see how the drive(s) are being</span>
<span class="sd">        rebalanced and the progress of adding the new drive.</span>

<span class="sd">        :param drives: [required] List of drives to add to the cluster.</span>
<span class="sd">        :type drives: NewDrive[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddDrivesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;drives&quot;</span><span class="p">:</span> <span class="n">drives</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddDrives&#39;</span><span class="p">,</span>
            <span class="n">AddDrivesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_drives">[docs]</a>    <span class="k">def</span> <span class="nf">list_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_drives* allows you to retrieve the list of the drives that exist</span>
<span class="sd">        in the cluster&#39;s active nodes.</span>
<span class="sd">        This method returns drives that have been added as volume metadata or</span>
<span class="sd">        block drives as well as drives that have not been added and are</span>
<span class="sd">        available.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListDrivesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListDrives&#39;</span><span class="p">,</span>
            <span class="n">ListDrivesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_drive_hardware_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_drive_hardware_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_drive_hardware_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drive_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_drive_hardware_info* returns all the hardware info for the given</span>
<span class="sd">        drive. This generally includes manufacturers, vendors, versions, and</span>
<span class="sd">        other associated hardware identification information.</span>

<span class="sd">        :param drive_id: [required] *drive_id* for the drive information</span>
<span class="sd">            requested. *drive_ids* can be obtained via the \&quot;ListDrives\&quot;</span>
<span class="sd">            method.</span>
<span class="sd">        :type drive_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetDriveHardwareInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;driveID&quot;</span><span class="p">:</span> <span class="n">drive_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetDriveHardwareInfo&#39;</span><span class="p">,</span>
            <span class="n">GetDriveHardwareInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_drive_hardware"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_drive_hardware">[docs]</a>    <span class="k">def</span> <span class="nf">list_drive_hardware</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">force</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_drive_hardware* returns all the drives connected to a node. Use</span>
<span class="sd">        this method on the cluster to return drive hardware information for all</span>
<span class="sd">        the drives on all nodes.</span>

<span class="sd">        :param force: [required] This must be set to true in order to retrieve</span>
<span class="sd">            the drive hardware stats from the cluster.</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListDriveHardwareResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;force&quot;</span><span class="p">:</span> <span class="n">force</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListDriveHardware&#39;</span><span class="p">,</span>
            <span class="n">ListDriveHardwareResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.reset_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.reset_drives">[docs]</a>    <span class="k">def</span> <span class="nf">reset_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drives</span><span class="p">,</span>
            <span class="n">force</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *reset_drives* is used to pro-actively initialize drives and remove all</span>
<span class="sd">        data currently residing on the drive. The drive can then be reused in</span>
<span class="sd">        an existing node or used in an upgraded SolidFire node. This method</span>
<span class="sd">        requires the force=true parameter to be included in the method call.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :param drives: [required] List of device names (not driveIDs) to reset.</span>
<span class="sd">        :type drives: str</span>

<span class="sd">        :param force: [required] The \&quot;force\&quot; parameter must be included on</span>
<span class="sd">            this method to successfully reset a drive.</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ResetDrivesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;drives&quot;</span><span class="p">:</span> <span class="n">drives</span><span class="p">,</span>
            <span class="s2">&quot;force&quot;</span><span class="p">:</span> <span class="n">force</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ResetDrives&#39;</span><span class="p">,</span>
            <span class="n">ResetDrivesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_drives">[docs]</a>    <span class="k">def</span> <span class="nf">test_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">force</span><span class="p">,</span>
            <span class="n">minutes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_drives* API method is used to run a hardware validation on</span>
<span class="sd">        all the drives on the node. Hardware failures on the drives are</span>
<span class="sd">        detected if present and they are reported in the results of the</span>
<span class="sd">        validation tests.</span>




<span class="sd">        **Note**: This test takes approximately 10 minutes.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :param force: [required] The \&quot;force\&quot; parameter must be included on</span>
<span class="sd">            this method to successfully test the drives on the node.</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :param minutes: (optional) The number of minutes to run the test can be</span>
<span class="sd">            specified.</span>
<span class="sd">        :type minutes: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestDrivesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;force&quot;</span><span class="p">:</span> <span class="n">force</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">minutes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;minutes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">minutes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestDrives&#39;</span><span class="p">,</span>
            <span class="n">TestDrivesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_drive_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_drive_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_drive_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drive_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_drive_stats* return high-level activity measurements for a single</span>
<span class="sd">        drive. Values are cumulative from the addition of the drive to the</span>
<span class="sd">        cluster. Some values are specific to Block Drives. Statistical data may</span>
<span class="sd">        not be returned for both block and metadata drives when running this</span>
<span class="sd">        method.</span>
<span class="sd">        For more information on which drive type returns which data, see</span>
<span class="sd">        Response Example (Block Drive) and Response Example (Volume Metadata</span>
<span class="sd">        Drive) in the SolidFire API guide.</span>

<span class="sd">        :param drive_id: [required] Specifies the drive for which statistics</span>
<span class="sd">            are gathered.</span>
<span class="sd">        :type drive_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetDriveStatsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;driveID&quot;</span><span class="p">:</span> <span class="n">drive_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetDriveStats&#39;</span><span class="p">,</span>
            <span class="n">GetDriveStatsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.secure_erase_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.secure_erase_drives">[docs]</a>    <span class="k">def</span> <span class="nf">secure_erase_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drives</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *secure_erase_drives* is used to remove any residual data from drives</span>
<span class="sd">        that have a status of \&quot;available.\&quot; For example, when replacing a</span>
<span class="sd">        drive at its end-of-life that contained sensitive data.</span>
<span class="sd">        It uses a Security Erase Unit command to write a predetermined pattern</span>
<span class="sd">        to the drive and resets the encryption key on the drive. The method may</span>
<span class="sd">        take up to two minutes to complete, so it is an asynchronous method.</span>
<span class="sd">        The *get_async_result* method can be used to check on the status of the</span>
<span class="sd">        secure erase operation.</span>




<span class="sd">        Use the *\&quot;list_drives\&quot;* method to obtain the *drive_ids* for the</span>
<span class="sd">        drives you want to secure erase.</span>

<span class="sd">        :param drives: [required] List of *drive_ids* to secure erase.</span>
<span class="sd">        :type drives: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AsyncHandleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;drives&quot;</span><span class="p">:</span> <span class="n">drives</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SecureEraseDrives&#39;</span><span class="p">,</span>
            <span class="n">AsyncHandleResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_drives"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_drives">[docs]</a>    <span class="k">def</span> <span class="nf">remove_drives</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">drives</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use *remove_drives* to proactively remove drives that are part</span>
<span class="sd">        of the cluster.</span>
<span class="sd">        You may want to use this method when reducing cluster capacity or</span>
<span class="sd">        preparing to replace drives nearing the end of their service life.</span>
<span class="sd">        Any data on the drives is removed and migrated to other drives in the</span>
<span class="sd">        cluster before the drive is removed from the cluster. This is an</span>
<span class="sd">        asynchronous method.</span>
<span class="sd">        Depending on the total capacity of the drives being removed, it may</span>
<span class="sd">        take several minutes to migrate all of the data.</span>
<span class="sd">        Use the *\&quot;get_async_result\&quot;* method to check the status of the remove</span>
<span class="sd">        operation.</span>




<span class="sd">        When removing multiple drives, use a single *\&quot;remove_drives\&quot;* method</span>
<span class="sd">        call rather than multiple individual methods with a single drive each.</span>
<span class="sd">        This reduces the amount of data balancing that must occur to even</span>
<span class="sd">        stabilize the storage load on the cluster.</span>




<span class="sd">        You can also remove drives with a \&quot;failed\&quot; status using</span>
<span class="sd">        \&quot;RemoveDrives\&quot;.</span>
<span class="sd">        When you remove a drive with a \&quot;failed\&quot; status it is not returned to</span>
<span class="sd">        an \&quot;available\&quot; or \&quot;active\&quot; status.</span>
<span class="sd">        The drive is unavailable for use in the cluster.</span>




<span class="sd">        Use the *\&quot;list_drives\&quot;* method to obtain the *drive_ids* for the</span>
<span class="sd">        drives you want to remove.</span>

<span class="sd">        :param drives: [required] List of *drive_ids* to remove from the</span>
<span class="sd">            cluster.</span>
<span class="sd">        :type drives: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AsyncHandleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;drives&quot;</span><span class="p">:</span> <span class="n">drives</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveDrives&#39;</span><span class="p">,</span>
            <span class="n">AsyncHandleResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_fibre_channel_port_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_fibre_channel_port_info">[docs]</a>    <span class="k">def</span> <span class="nf">list_fibre_channel_port_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_fibre_channel_port_info* is used to return information about</span>
<span class="sd">        the Fibre Channel ports. The API method is intended for use on</span>
<span class="sd">        individual nodes; userid and password is required for access to</span>
<span class="sd">        individual Fibre Channel nodes. However, this method can be used on the</span>
<span class="sd">        cluster if the force=true parameter is included in the method call.</span>
<span class="sd">        When used on the cluster, all Fibre Channel interfaces are listed.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListFibreChannelPortInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListFibreChannelPortInfo&#39;</span><span class="p">,</span>
            <span class="n">ListFibreChannelPortInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_node_fibre_channel_port_info"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_node_fibre_channel_port_info">[docs]</a>    <span class="k">def</span> <span class="nf">list_node_fibre_channel_port_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">force</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_node_fibre_channel_port_info* is used to return information</span>
<span class="sd">        about the Fibre Channel ports. The API method is intended for use on</span>
<span class="sd">        individual nodes; userid and password is required for access to</span>
<span class="sd">        individual Fibre Channel nodes. However, this method can be used on the</span>
<span class="sd">        cluster if the force=true parameter is included in the method call.</span>
<span class="sd">        When used on the cluster, all Fibre Channel interfaces are listed.</span>

<span class="sd">        :param force: (optional) Specify force=true to call method on all</span>
<span class="sd">            member nodes of the cluster.</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListNodeFibreChannelPortInfoResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;force&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">force</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListNodeFibreChannelPortInfo&#39;</span><span class="p">,</span>
            <span class="n">ListNodeFibreChannelPortInfoResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_fibre_channel_sessions"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_fibre_channel_sessions">[docs]</a>    <span class="k">def</span> <span class="nf">list_fibre_channel_sessions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_fibre_channel_sessions* is used to return information about</span>
<span class="sd">        the active Fibre Channel sessions on a cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListFibreChannelSessionsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListFibreChannelSessions&#39;</span><span class="p">,</span>
            <span class="n">ListFibreChannelSessionsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_ldap_cluster_admin"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_ldap_cluster_admin">[docs]</a>    <span class="k">def</span> <span class="nf">add_ldap_cluster_admin</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">username</span><span class="p">,</span>
            <span class="n">access</span><span class="p">,</span>
            <span class="n">accept_eula</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *add_ldap_cluster_admin* is used to add a new LDAP Cluster Admin. An</span>
<span class="sd">        LDAP Cluster Admin can be used to manage the cluster via the API and</span>
<span class="sd">        management tools. LDAP Cluster Admins are completely separate and</span>
<span class="sd">        unrelated to standard tenant accounts.</span>




<span class="sd">        An LDAP group that has been defined in Active Directory can also be</span>
<span class="sd">        added using this API method. The access level that is given to the</span>
<span class="sd">        group will be passed to the individual users in the LDAP group.</span>

<span class="sd">        :param username: [required] The distinguished user name for the new</span>
<span class="sd">            LDAP cluster admin.</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :param access: [required] Controls which methods this Cluster Admin can</span>
<span class="sd">            use. For more details on the levels of access, see the Access</span>
<span class="sd">            Control appendix in the SolidFire API Reference.</span>
<span class="sd">        :type access: str[]</span>

<span class="sd">        :param accept_eula: (optional) Indicate your acceptance of the End User</span>
<span class="sd">            License Agreement when creating this cluster admin. To accept the</span>
<span class="sd">            EULA, set this parameter to true.</span>
<span class="sd">        :type accept_eula: bool</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddLdapClusterAdminResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
            <span class="s2">&quot;access&quot;</span><span class="p">:</span> <span class="n">access</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;add_ldap_cluster_admin&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;accept_eula&quot;</span><span class="p">,</span>
                 <span class="n">accept_eula</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">accept_eula</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;acceptEula&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">accept_eula</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddLdapClusterAdmin&#39;</span><span class="p">,</span>
            <span class="n">AddLdapClusterAdminResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_ldap_authentication"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_ldap_authentication">[docs]</a>    <span class="k">def</span> <span class="nf">test_ldap_authentication</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">username</span><span class="p">,</span>
            <span class="n">password</span><span class="p">,</span>
            <span class="n">ldap_configuration</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_ldap_authentication* is used to verify the currently enabled</span>
<span class="sd">        LDAP authentication configuration settings are correct. If the</span>
<span class="sd">        configuration settings are correct, the API call returns a list of the</span>
<span class="sd">        groups the tested user is a member of.</span>

<span class="sd">        :param username: [required] The username to be tested.</span>
<span class="sd">        :type username: str</span>

<span class="sd">        :param password: [required] The password for the username to be tester.</span>
<span class="sd">        :type password: str</span>

<span class="sd">        :param ldap_configuration: (optional) An *ldap_configuration* object to</span>
<span class="sd">            be tested. If this parameter is provided, the API call will test</span>
<span class="sd">            the provided configuration even if LDAP authentication is currently</span>
<span class="sd">            disabled.</span>
<span class="sd">        :type ldap_configuration: LdapConfiguration</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestLdapAuthenticationResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;username&quot;</span><span class="p">:</span> <span class="n">username</span><span class="p">,</span>
            <span class="s2">&quot;password&quot;</span><span class="p">:</span> <span class="n">password</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">ldap_configuration</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;ldapConfiguration&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ldap_configuration</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestLdapAuthentication&#39;</span><span class="p">,</span>
            <span class="n">TestLdapAuthenticationResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_ldap_configuration"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_ldap_configuration">[docs]</a>    <span class="k">def</span> <span class="nf">get_ldap_configuration</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_ldap_configuration* is used to get the LDAP configuration</span>
<span class="sd">        currently active on the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetLdapConfigurationResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetLdapConfiguration&#39;</span><span class="p">,</span>
            <span class="n">GetLdapConfigurationResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.enable_ldap_authentication"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.enable_ldap_authentication">[docs]</a>    <span class="k">def</span> <span class="nf">enable_ldap_authentication</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">server_uris</span><span class="p">,</span>
            <span class="n">auth_type</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">group_search_base_dn</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">group_search_custom_filter</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">group_search_type</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">search_bind_dn</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">search_bind_password</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">user_dntemplate</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">user_search_base_dn</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">user_search_filter</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *enable_ldap_authentication* method is used to configure an LDAP</span>
<span class="sd">        server connection to use for LDAP authentication to a SolidFire</span>
<span class="sd">        cluster. Users that are members on the LDAP server can then log in to a</span>
<span class="sd">        SolidFire storage system using their LDAP authentication userid and</span>
<span class="sd">        password.</span>

<span class="sd">        :param server_uris: [required] A list of LDAP server *uris* (examples:</span>
<span class="sd">            \&quot;ldap://1.2.3.4\&quot; and ldaps://1.2.3.4:123\&quot;)</span>
<span class="sd">        :type server_uris: str[]</span>

<span class="sd">        :param auth_type: (optional) Identifies which user authentcation method</span>
<span class="sd">            will be used.</span>

<span class="sd">            Must be one of the following:</span>

<span class="sd">            **DirectBind**</span>

<span class="sd">            **SearchAndBind** (default)</span>

<span class="sd">        :type auth_type: str</span>

<span class="sd">        :param group_search_base_dn: (optional) The base DN of the tree to</span>
<span class="sd">            start the group search (will do a subtree search from here).</span>
<span class="sd">        :type group_search_base_dn: str</span>

<span class="sd">        :param group_search_custom_filter: (optional) REQUIRED for</span>
<span class="sd">            *custom_filter*</span>

<span class="sd">            For use with the *custom_filter* search type, an LDAP filter to use</span>
<span class="sd">            to return the *dns* of a user&#39;s groups.</span>

<span class="sd">            The string can have placeholder text of %USERNAME% and %USERDN% to</span>
<span class="sd">            be replaced with their username and full *user_dn* as needed.</span>

<span class="sd">        :type group_search_custom_filter: str</span>

<span class="sd">        :param group_search_type: (optional) Controls the default group search</span>
<span class="sd">            filter used, can be one of the following:</span>

<span class="sd">            **NoGroups**: No group support.</span>

<span class="sd">            **ActiveDirectory**: (default) Nested membership of all of a user&#39;s</span>
<span class="sd">            AD groups.</span>

<span class="sd">            **MemberDN**: *member_dn* style groups (single-level).</span>

<span class="sd">        :type group_search_type: str</span>

<span class="sd">        :param search_bind_dn: (optional) REQUIRED for *search_and_bind*</span>

<span class="sd">            A fully qualified DN to log in with to perform an LDAP search for</span>
<span class="sd">            the user (needs read access to the LDAP directory).</span>

<span class="sd">        :type search_bind_dn: str</span>

<span class="sd">        :param search_bind_password: (optional) REQUIRED for *search_and_bind*</span>

<span class="sd">            The password for the *search_bind_dn* account used for searching.</span>

<span class="sd">        :type search_bind_password: str</span>

<span class="sd">        :param user_dntemplate: (optional) REQUIRED for *direct_bind*</span>

<span class="sd">            A string that is used to form a fully qualified user DN.</span>

<span class="sd">            The string should have the placeholder text \&quot;%USERNAME%\&quot; which</span>
<span class="sd">            will be replaced with the username of the authenticating user.</span>

<span class="sd">        :type user_dntemplate: str</span>

<span class="sd">        :param user_search_base_dn: (optional) REQUIRED for *search_and_bind*</span>
<span class="sd">            The base DN of the tree used to start the search (will do a subtree</span>
<span class="sd">            search from here).</span>
<span class="sd">        :type user_search_base_dn: str</span>

<span class="sd">        :param user_search_filter: (optional) REQUIRED for SearchAndBind.</span>

<span class="sd">            The LDAP filter to use.</span>

<span class="sd">            The string should have the placeholder text \&quot;%USERNAME%\&quot; which</span>
<span class="sd">            will be replaced with the username of the authenticating user.</span>

<span class="sd">            Example: (&amp;(objectClass=person) (sAMAccountName=%USERNAME%)) will</span>
<span class="sd">            use the *s_amaccount_name* field in Active Directory to match the</span>
<span class="sd">            nusername entered at cluster login.</span>

<span class="sd">        :type user_search_filter: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: EnableLdapAuthenticationResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;serverURIs&quot;</span><span class="p">:</span> <span class="n">server_uris</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">auth_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;authType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">auth_type</span>
        <span class="k">if</span> <span class="n">group_search_base_dn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;groupSearchBaseDN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_search_base_dn</span>
        <span class="k">if</span> <span class="n">group_search_custom_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;groupSearchCustomFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_search_custom_filter</span>
        <span class="k">if</span> <span class="n">group_search_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;groupSearchType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_search_type</span>
        <span class="k">if</span> <span class="n">search_bind_dn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;searchBindDN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">search_bind_dn</span>
        <span class="k">if</span> <span class="n">search_bind_password</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;searchBindPassword&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">search_bind_password</span>
        <span class="k">if</span> <span class="n">user_dntemplate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;userDNTemplate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_dntemplate</span>
        <span class="k">if</span> <span class="n">user_search_base_dn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;userSearchBaseDN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_search_base_dn</span>
        <span class="k">if</span> <span class="n">user_search_filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;userSearchFilter&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_search_filter</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;EnableLdapAuthentication&#39;</span><span class="p">,</span>
            <span class="n">EnableLdapAuthenticationResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.disable_ldap_authentication"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.disable_ldap_authentication">[docs]</a>    <span class="k">def</span> <span class="nf">disable_ldap_authentication</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *disable_ldap_authentication* method is used disable LDAP</span>
<span class="sd">        authentication and remove all LDAP configuration settings. This call</span>
<span class="sd">        will not remove any configured cluster admin accounts (user or group).</span>
<span class="sd">        However, those cluster admin accounts will no longer be able to log in.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DisableLdapAuthenticationResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DisableLdapAuthentication&#39;</span><span class="p">,</span>
            <span class="n">DisableLdapAuthenticationResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_active_nodes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_active_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">list_active_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_active_nodes* returns the list of currently active nodes that are</span>
<span class="sd">        in the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListActiveNodesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListActiveNodes&#39;</span><span class="p">,</span>
            <span class="n">ListActiveNodesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_all_nodes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_all_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">list_all_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_all_nodes* enables you to retrieve a list of active and pending</span>
<span class="sd">        nodes in the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListAllNodesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListAllNodes&#39;</span><span class="p">,</span>
            <span class="n">ListAllNodesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_pending_nodes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_pending_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">list_pending_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the list of pending nodes.</span>
<span class="sd">        Pending nodes are running and configured to join the cluster, but have</span>
<span class="sd">        not been added via the *add_nodes* method.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListPendingNodesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListPendingNodes&#39;</span><span class="p">,</span>
            <span class="n">ListPendingNodesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_nodes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">add_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">pending_nodes</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *add_nodes* is used to add one or more new nodes to the cluster. When a</span>
<span class="sd">        node is not configured and starts up for the first time you are</span>
<span class="sd">        prompted to configure the node. Once a node is configured it is</span>
<span class="sd">        registered as a \&quot;pending node\&quot; with the cluster.</span>




<span class="sd">        Adding a node to a cluster that has been set up for virtual networking</span>
<span class="sd">        will require a sufficient number of virtual storage IP addresses to</span>
<span class="sd">        allocate a virtual IP to the new node. If there are no virtual IP</span>
<span class="sd">        addresses available for the new node, the *add_node* operation will not</span>
<span class="sd">        complete successfully. Use the *\&quot;modify_virtual_network\&quot;* method to</span>
<span class="sd">        add more storage IP addresses to your virtual network.</span>




<span class="sd">        The software version on each node in a cluster must be compatible. Run</span>
<span class="sd">        the *\&quot;list_all_nodes\&quot;* API to see what versions of software are</span>
<span class="sd">        currently running on the cluster nodes. For an explanation of software</span>
<span class="sd">        version compatibility, see *\&quot;node* Versioning and Compatibility\&quot; in</span>
<span class="sd">        the Element API guide.</span>




<span class="sd">        Once a node has been added, the drives on the node are made available</span>
<span class="sd">        and can then be added via the *\&quot;add_drives\&quot;* method to increase the</span>
<span class="sd">        storage capacity of the cluster.</span>




<span class="sd">        **Note**: It may take several seconds after adding a new Node for it to</span>
<span class="sd">        start up and register the drives as being available.</span>

<span class="sd">        :param pending_nodes: [required] List of *pending_node_ids* for the</span>
<span class="sd">            Nodes to be added. You can obtain the list of Pending Nodes via the</span>
<span class="sd">            *list_pending_nodes* method.</span>
<span class="sd">        :type pending_nodes: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddNodesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;pendingNodes&quot;</span><span class="p">:</span> <span class="n">pending_nodes</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddNodes&#39;</span><span class="p">,</span>
            <span class="n">AddNodesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_nodes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_nodes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">nodes</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *remove_nodes* is used to remove one or more nodes that should no</span>
<span class="sd">        longer participate in the cluster. Before removing a node, all drives</span>
<span class="sd">        it contains must first be removed with *\&quot;remove_drives\&quot;* method. A</span>
<span class="sd">        node cannot be removed until the *remove_drives* process has completed</span>
<span class="sd">        and all data has been migrated away from the node.</span>




<span class="sd">        Once removed, a node registers itself as a pending node and can be</span>
<span class="sd">        added again, or shut down which removes it from the *\&quot;pending* Node\&quot;</span>
<span class="sd">        list.</span>

<span class="sd">        :param nodes: [required] List of *node_ids* for the nodes to be</span>
<span class="sd">            removed.</span>
<span class="sd">        :type nodes: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveNodesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nodes&quot;</span><span class="p">:</span> <span class="n">nodes</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveNodes&#39;</span><span class="p">,</span>
            <span class="n">RemoveNodesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_network_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_network_config">[docs]</a>    <span class="k">def</span> <span class="nf">get_network_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_network_config* API method is used to display the network</span>
<span class="sd">        configuration information for a node.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetNetworkConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetNetworkConfig&#39;</span><span class="p">,</span>
            <span class="n">GetNetworkConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">config</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *set_config* API method is used to set all the configuration</span>
<span class="sd">        information for the node. This includes the same information available</span>
<span class="sd">        via calls to *set_cluster_config* and *set_network_config* in one API</span>
<span class="sd">        method.</span>




<span class="sd">        **Warning!** Changing the &#39;bond-mode&#39; on a node can cause a temporary</span>
<span class="sd">        loss of network connectivity. Caution should be taken when using this</span>
<span class="sd">        method.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :param config: [required] Objects that you want changed for the cluster</span>
<span class="sd">            interface settings.</span>
<span class="sd">        :type config: Config</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;config&quot;</span><span class="p">:</span> <span class="n">config</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetConfig&#39;</span><span class="p">,</span>
            <span class="n">SetConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.set_network_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.set_network_config">[docs]</a>    <span class="k">def</span> <span class="nf">set_network_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">network</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *\&quot;set_network_config\&quot;* method is used to set the network</span>
<span class="sd">        configuration for a node. To see the states in which these objects can</span>
<span class="sd">        be modified, see *\&quot;network* Object for 1G and 10G Interfaces\&quot; on page</span>
<span class="sd">        109 of the Element API. To display the current network settings for a</span>
<span class="sd">        node, run the *\&quot;get_network_config\&quot;* method.</span>




<span class="sd">        **WARNING!** Changing the \&quot;bond-mode\&quot; on a node can cause a temporary</span>
<span class="sd">        loss of network connectivity. Caution should be taken when using this</span>
<span class="sd">        method.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :param network: [required] Objects that will be changed for the node</span>
<span class="sd">            network settings.</span>
<span class="sd">        :type network: Network</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: SetNetworkConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;network&quot;</span><span class="p">:</span> <span class="n">network</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;SetNetworkConfig&#39;</span><span class="p">,</span>
            <span class="n">SetNetworkConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_config"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_config">[docs]</a>    <span class="k">def</span> <span class="nf">get_config</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_config* API method is used to retrieve all the configuration</span>
<span class="sd">        information for the node. This one API method includes the same</span>
<span class="sd">        information available in both *\&quot;get_cluster_config\&quot;* and</span>
<span class="sd">        *\&quot;get_network_config\&quot;* methods.</span>




<span class="sd">        **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetConfigResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetConfig&#39;</span><span class="p">,</span>
            <span class="n">GetConfigResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_node_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_node_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">node_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_node_stats* is used to return the high-level activity measurements</span>
<span class="sd">        for a single node.</span>

<span class="sd">        :param node_id: [required] Specifies the node for which statistics are</span>
<span class="sd">            gathered.</span>
<span class="sd">        :type node_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetNodeStatsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;nodeID&quot;</span><span class="p">:</span> <span class="n">node_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">since</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ElementServiceAdaptor</span><span class="o">.</span><span class="n">get_node_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                                    <span class="n">since</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_node_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_node_stats">[docs]</a>    <span class="k">def</span> <span class="nf">list_node_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_node_stats* is used to return the high-level activity</span>
<span class="sd">        measurements for all nodes in a cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListNodeStatsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListNodeStats&#39;</span><span class="p">,</span>
            <span class="n">ListNodeStatsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_cluster_pairs"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_cluster_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">list_cluster_pairs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_cluster_pairs* is used to list all of the clusters a cluster is</span>
<span class="sd">        paired with.</span>
<span class="sd">        This method returns information about active and pending cluster</span>
<span class="sd">        pairings, such as statistics about the current pairing as well as the</span>
<span class="sd">        connectivity and latency (in milliseconds) of the cluster pairing.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListClusterPairsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListClusterPairs&#39;</span><span class="p">,</span>
            <span class="n">ListClusterPairsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_active_paired_volumes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_active_paired_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">list_active_paired_volumes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_active_paired_volumes* is used to list all of the active volumes</span>
<span class="sd">        paired with a volume.</span>
<span class="sd">        Volumes listed in the return for this method include volumes with</span>
<span class="sd">        active and pending pairings.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListActivePairedVolumesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListActivePairedVolumes&#39;</span><span class="p">,</span>
            <span class="n">ListActivePairedVolumesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.start_cluster_pairing"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.start_cluster_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">start_cluster_pairing</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *start_cluster_pairing* is used to create an encoded key from a cluster</span>
<span class="sd">        that is used to pair with another cluster.</span>
<span class="sd">        The key created from this API method is used in the</span>
<span class="sd">        *\&quot;complete_cluster_pairing\&quot;* API method to establish a cluster</span>
<span class="sd">        pairing.</span>
<span class="sd">        You can pair a cluster with a maximum of four other SolidFire clusters.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: StartClusterPairingResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;StartClusterPairing&#39;</span><span class="p">,</span>
            <span class="n">StartClusterPairingResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.start_volume_pairing"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.start_volume_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">start_volume_pairing</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *start_volume_pairing* is used to create an encoded key from a volume</span>
<span class="sd">        that is used to pair with another volume.</span>
<span class="sd">        The key that this method creates is used in the</span>
<span class="sd">        *\&quot;complete_volume_pairing\&quot;* API method to establish a volume pairing.</span>

<span class="sd">        :param volume_id: [required] The ID of the volume on which to start the</span>
<span class="sd">            pairing process.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param mode: (optional) The mode of the volume on which to start the</span>
<span class="sd">            pairing process. The mode can only be set if the volume is the</span>
<span class="sd">            source volume.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            **Async**: (default if no mode parameter specified) Writes are</span>
<span class="sd">            acknowledged when they complete locally. The cluster does not wait</span>
<span class="sd">            for writes to be replicated to the target cluster.</span>

<span class="sd">            **Sync**: Source acknowledges write when the data is stored locally</span>
<span class="sd">            and on the remote cluster.</span>

<span class="sd">            **SnapshotsOnly**: Only snapshots created on the source cluster</span>
<span class="sd">            will be replicated. Active writes from the source volume will not</span>
<span class="sd">            be replicated.</span>



<span class="sd">        :type mode: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: StartVolumePairingResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;StartVolumePairing&#39;</span><span class="p">,</span>
            <span class="n">StartVolumePairingResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.complete_cluster_pairing"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.complete_cluster_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">complete_cluster_pairing</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster_pairing_key</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *complete_cluster_pairing* method is the second step in the cluster</span>
<span class="sd">        pairing process.</span>
<span class="sd">        Use this method with the encoded key received from the</span>
<span class="sd">        *\&quot;start_cluster_pairing\&quot;* API method to complete the cluster pairing</span>
<span class="sd">        process.</span>

<span class="sd">        :param cluster_pairing_key: [required] A string of characters that is</span>
<span class="sd">            returned from the \&quot;StartClusterPairing\&quot; API method.</span>
<span class="sd">        :type cluster_pairing_key: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CompleteClusterPairingResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;clusterPairingKey&quot;</span><span class="p">:</span> <span class="n">cluster_pairing_key</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CompleteClusterPairing&#39;</span><span class="p">,</span>
            <span class="n">CompleteClusterPairingResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.complete_volume_pairing"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.complete_volume_pairing">[docs]</a>    <span class="k">def</span> <span class="nf">complete_volume_pairing</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_pairing_key</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *complete_volume_pairing* is used to complete the pairing of two</span>
<span class="sd">        volumes.</span>

<span class="sd">        :param volume_pairing_key: [required] The key returned from the</span>
<span class="sd">            \&quot;StartVolumePairing\&quot; API method.</span>
<span class="sd">        :type volume_pairing_key: str</span>

<span class="sd">        :param volume_id: [required] The ID of volume on which to complete the</span>
<span class="sd">            pairing process.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CompleteVolumePairingResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumePairingKey&quot;</span><span class="p">:</span> <span class="n">volume_pairing_key</span><span class="p">,</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CompleteVolumePairing&#39;</span><span class="p">,</span>
            <span class="n">CompleteVolumePairingResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_cluster_pair"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_cluster_pair">[docs]</a>    <span class="k">def</span> <span class="nf">remove_cluster_pair</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">cluster_pair_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use the *remove_cluster_pair* method to close the open</span>
<span class="sd">        connections between two paired clusters.</span>



<span class="sd">        **Note**: Before you remove a cluster pair, you must first remove all</span>
<span class="sd">        volume pairing to the clusters with the *\&quot;remove_volume_pair\&quot;* API</span>
<span class="sd">        method.</span>

<span class="sd">        :param cluster_pair_id: [required] Unique identifier used to pair two</span>
<span class="sd">            clusters.</span>
<span class="sd">        :type cluster_pair_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveClusterPairResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;clusterPairID&quot;</span><span class="p">:</span> <span class="n">cluster_pair_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveClusterPair&#39;</span><span class="p">,</span>
            <span class="n">RemoveClusterPairResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_volume_pair"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_volume_pair">[docs]</a>    <span class="k">def</span> <span class="nf">remove_volume_pair</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *remove_volume_pair* is used to remove the remote pairing between two</span>
<span class="sd">        volumes.</span>
<span class="sd">        When the volume pairing information is removed, data is no longer</span>
<span class="sd">        replicated to or from the volume.</span>
<span class="sd">        This method should be run on both the source and target volumes that</span>
<span class="sd">        are paired together.</span>

<span class="sd">        :param volume_id: [required] ID of the volume on which to stop the</span>
<span class="sd">            replication process.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveVolumePairResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveVolumePair&#39;</span><span class="p">,</span>
            <span class="n">RemoveVolumePairResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_volume_pair"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_volume_pair">[docs]</a>    <span class="k">def</span> <span class="nf">modify_volume_pair</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">paused_manual</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_volume_pair* is used to pause or restart replication between a</span>
<span class="sd">        pair of volumes.</span>

<span class="sd">        :param volume_id: [required] Identification number of the volume to be</span>
<span class="sd">            modified.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param paused_manual: (optional) Valid values that can be entered:</span>

<span class="sd">            **true**: to pause volume replication.</span>

<span class="sd">            **false**: to restart volume replication.</span>

<span class="sd">            If no value is specified, no change in replication is performed.</span>

<span class="sd">        :type paused_manual: bool</span>

<span class="sd">        :param mode: (optional) Volume replication mode.</span>

<span class="sd">            Possible values:</span>

<span class="sd">            **Async**: Writes are acknowledged when they complete locally. The</span>
<span class="sd">            cluster does not wait for writes to be replicated to the target</span>
<span class="sd">            cluster.</span>

<span class="sd">            **Sync**: The source acknowledges the write when the data is stored</span>
<span class="sd">            locally and on the remote cluster.</span>

<span class="sd">            **SnapshotsOnly**: Only snapshots created on the source cluster</span>
<span class="sd">            will be replicated. Active writes from the source volume are not</span>
<span class="sd">            replicated.</span>



<span class="sd">        :type mode: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumePairResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">paused_manual</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;pausedManual&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">paused_manual</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mode&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mode</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyVolumePair&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumePairResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">create_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">enable_remote_replication</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">retention</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *create_snapshot* is used to create a point-in-time copy of a volume.</span>
<span class="sd">        A snapshot can be created from any volume or from an existing snapshot.</span>




<span class="sd">        **Note**: Creating a snapshot is allowed if cluster fullness is at</span>
<span class="sd">        stage 2 or 3.</span>
<span class="sd">        Snapshots are not created when cluster fullness is at stage 4 or 5.</span>

<span class="sd">        :param volume_id: [required] ID of the volume image from which to copy.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param snapshot_id: (optional) Unique ID of a snapshot from which the</span>
<span class="sd">            new snapshot is made. The *snapshot_id* passed must be a snapshot</span>
<span class="sd">            on the given volume. If a *snapshot_id* is not provided, a snapshot</span>
<span class="sd">            is created from the volume&#39;s active branch.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :param name: (optional) A name for the snapshot. If no name is</span>
<span class="sd">            provided, the date and time the snapshot was taken is used.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param enable_remote_replication: (optional) Identifies if snapshot is</span>
<span class="sd">            enabled for remote replication.</span>
<span class="sd">        :type enable_remote_replication: bool</span>

<span class="sd">        :param retention: (optional) The amount of time the snapshot will be</span>
<span class="sd">            retained. Enter in *hh:mm:ss*</span>
<span class="sd">        :type retention: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;create_snapshot&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;enable_remote_replication&quot;</span><span class="p">,</span>
                 <span class="n">enable_remote_replication</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;retention&quot;</span><span class="p">,</span>
                 <span class="n">retention</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">snapshot_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;snapshotID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot_id</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">enable_remote_replication</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;enableRemoteReplication&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enable_remote_replication</span>
        <span class="k">if</span> <span class="n">retention</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;retention&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retention</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CreateSnapshot&#39;</span><span class="p">,</span>
            <span class="n">CreateSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.delete_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.delete_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">delete_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *delete_snapshot* is used to delete a snapshot.</span>
<span class="sd">        A snapshot that is currently the \&quot;active\&quot; snapshot cannot be deleted.</span>
<span class="sd">        You must rollback and make another snapshot \&quot;active\&quot; before the</span>
<span class="sd">        current snapshot can be deleted.</span>
<span class="sd">        To rollback a snapshot, use RollbackToSnapshot.</span>

<span class="sd">        :param snapshot_id: [required] The ID of the snapshot to delete.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DeleteSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;snapshotID&quot;</span><span class="p">:</span> <span class="n">snapshot_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DeleteSnapshot&#39;</span><span class="p">,</span>
            <span class="n">DeleteSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_snapshots"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_snapshots">[docs]</a>    <span class="k">def</span> <span class="nf">list_snapshots</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_snapshots* is used to return the attributes of each snapshot</span>
<span class="sd">        taken on the volume.</span>

<span class="sd">        :param volume_id: (optional) The volume to list snapshots for. If not</span>
<span class="sd">            provided, all snapshots for all volumes are returned.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListSnapshotsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">volume_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumeID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_id</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListSnapshots&#39;</span><span class="p">,</span>
            <span class="n">ListSnapshotsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">modify_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="p">,</span>
            <span class="n">expiration_time</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">enable_remote_replication</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_snapshot* is used to change the attributes currently assigned</span>
<span class="sd">        to a snapshot.</span>
<span class="sd">        Use this API method to enable the snapshots created on the Read/Write</span>
<span class="sd">        (source) volume to be remotely replicated to a target SolidFire storage</span>
<span class="sd">        system.</span>

<span class="sd">        :param snapshot_id: [required] ID of the snapshot.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :param expiration_time: (optional) Use to set the time when the</span>
<span class="sd">            snapshot should be removed.</span>
<span class="sd">        :type expiration_time: str</span>

<span class="sd">        :param enable_remote_replication: (optional) Use to enable the snapshot</span>
<span class="sd">            created to be replicated to a remote SolidFire cluster. Possible</span>
<span class="sd">            values:</span>

<span class="sd">            **true**: the snapshot will be replicated to remote storage.</span>

<span class="sd">            **false**: Default. No replication.</span>

<span class="sd">        :type enable_remote_replication: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifySnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;snapshotID&quot;</span><span class="p">:</span> <span class="n">snapshot_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">expiration_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;expirationTime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expiration_time</span>
        <span class="k">if</span> <span class="n">enable_remote_replication</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;enableRemoteReplication&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enable_remote_replication</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifySnapshot&#39;</span><span class="p">,</span>
            <span class="n">ModifySnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.rollback_to_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.rollback_to_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">rollback_to_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="p">,</span>
            <span class="n">save_current_state</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *rollback_to_snapshot* is used to make an existing snapshot the</span>
<span class="sd">        \&quot;active\&quot; volume image. This method creates a new</span>
<span class="sd">        snapshot from an existing snapshot. The new snapshot becomes \&quot;active\&quot;</span>
<span class="sd">        and the existing snapshot is preserved until</span>
<span class="sd">        it is manually deleted. The previously \&quot;active\&quot; snapshot is deleted</span>
<span class="sd">        unless the parameter *save_current_state* is set with</span>
<span class="sd">        a value of \&quot;true.\&quot;</span>
<span class="sd">        **Note**: Creating a snapshot is allowed if cluster fullness is at</span>
<span class="sd">        stage 2 or 3.</span>
<span class="sd">        Snapshots are not created when cluster fullness is at stage 4 or 5.</span>

<span class="sd">        :param volume_id: [required] *volume_id* for the volume.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param snapshot_id: [required] ID of a previously created snapshot on</span>
<span class="sd">            the given volume.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :param save_current_state: [required]</span>

<span class="sd">            **true**: The previous active volume image is kept.</span>

<span class="sd">            **false**: (default) The previous active volume image is deleted.</span>

<span class="sd">        :type save_current_state: bool</span>

<span class="sd">        :param name: (optional) Name for the snapshot. If no name is given,</span>
<span class="sd">            then the name of the snapshot being rolled back to is used with</span>
<span class="sd">            \&quot;-copy\&quot; appended to the end of the name.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
            <span class="s2">&quot;snapshotID&quot;</span><span class="p">:</span> <span class="n">snapshot_id</span><span class="p">,</span>
            <span class="s2">&quot;saveCurrentState&quot;</span><span class="p">:</span> <span class="n">save_current_state</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RollbackToSnapshot&#39;</span><span class="p">,</span>
            <span class="n">CreateSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_group_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_group_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">create_group_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volumes</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">enable_remote_replication</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">retention</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *create_group_snapshot* is used to create a point-in-time copy of a</span>
<span class="sd">        group of volumes.</span>
<span class="sd">        The snapshot created can then be used later as a backup or rollback to</span>
<span class="sd">        ensure the data on the group of volumes is consistent for the point in</span>
<span class="sd">        time in which the snapshot was created.</span>




<span class="sd">        **Note**: Creating a group snapshot is allowed if cluster fullness is</span>
<span class="sd">        at stage 2 or 3.</span>
<span class="sd">        Snapshots are not created when cluster fullness is at stage 4 or 5.</span>

<span class="sd">        :param volumes: [required] Unique ID of the volume image from which to</span>
<span class="sd">            copy.</span>
<span class="sd">        :type volumes: int[]</span>

<span class="sd">        :param name: (optional) A name for the snapshot. If no name is</span>
<span class="sd">            provided, the date and time the snapshot was taken is used.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param enable_remote_replication: (optional) Identifies if snapshot is</span>
<span class="sd">            enabled for remote replication.</span>
<span class="sd">        :type enable_remote_replication: bool</span>

<span class="sd">        :param retention: (optional) The amount of time the snapshot will be</span>
<span class="sd">            retained. Enter in *hh:mm:ss*</span>
<span class="sd">        :type retention: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateGroupSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumes&quot;</span><span class="p">:</span> <span class="n">volumes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;create_group_snapshot&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;enable_remote_replication&quot;</span><span class="p">,</span>
                 <span class="n">enable_remote_replication</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;retention&quot;</span><span class="p">,</span>
                 <span class="n">retention</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">enable_remote_replication</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;enableRemoteReplication&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enable_remote_replication</span>
        <span class="k">if</span> <span class="n">retention</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;retention&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">retention</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CreateGroupSnapshot&#39;</span><span class="p">,</span>
            <span class="n">CreateGroupSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.delete_group_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.delete_group_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">delete_group_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">group_snapshot_id</span><span class="p">,</span>
            <span class="n">save_members</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *delete_group_snapshot* is used to delete a group snapshot.</span>
<span class="sd">        The *save_members* parameter can be used to preserve all the snapshots</span>
<span class="sd">        that</span>
<span class="sd">        were made for the volumes in the group but the group association will</span>
<span class="sd">        be removed.</span>

<span class="sd">        :param group_snapshot_id: [required] Unique ID of the group snapshot.</span>
<span class="sd">        :type group_snapshot_id: int</span>

<span class="sd">        :param save_members: [required]</span>

<span class="sd">            **true**: Snapshots are kept, but group association is removed.</span>

<span class="sd">            **false**: The group and snapshots are deleted.</span>

<span class="sd">        :type save_members: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DeleteGroupSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;groupSnapshotID&quot;</span><span class="p">:</span> <span class="n">group_snapshot_id</span><span class="p">,</span>
            <span class="s2">&quot;saveMembers&quot;</span><span class="p">:</span> <span class="n">save_members</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DeleteGroupSnapshot&#39;</span><span class="p">,</span>
            <span class="n">DeleteGroupSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_group_snapshots"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_group_snapshots">[docs]</a>    <span class="k">def</span> <span class="nf">list_group_snapshots</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_group_snapshots* is used to return information about all group</span>
<span class="sd">        snapshots that have been created.</span>

<span class="sd">        :param volume_id: (optional) An array of unique volume *ids* to query.</span>
<span class="sd">            If this parameter is not specified, all group snapshots on the</span>
<span class="sd">            cluster will be included.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListGroupSnapshotsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">volume_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumeID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_id</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListGroupSnapshots&#39;</span><span class="p">,</span>
            <span class="n">ListGroupSnapshotsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_group_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_group_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">modify_group_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">group_snapshot_id</span><span class="p">,</span>
            <span class="n">expiration_time</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">enable_remote_replication</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_group_snapshot* is used to change the attributes currently</span>
<span class="sd">        assigned to a group snapshot.</span>

<span class="sd">        :param group_snapshot_id: [required] ID of the snapshot.</span>
<span class="sd">        :type group_snapshot_id: int</span>

<span class="sd">        :param expiration_time: (optional) Use to set the time when the</span>
<span class="sd">            snapshot should be removed.</span>
<span class="sd">        :type expiration_time: str</span>

<span class="sd">        :param enable_remote_replication: (optional) Use to enable the snapshot</span>
<span class="sd">            created to be replicated to a remote SolidFire cluster. Possible</span>
<span class="sd">            values:</span>

<span class="sd">            **true**: the snapshot will be replicated to remote storage.</span>

<span class="sd">            **false**: Default. No replication.</span>

<span class="sd">        :type enable_remote_replication: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyGroupSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;groupSnapshotID&quot;</span><span class="p">:</span> <span class="n">group_snapshot_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">expiration_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;expirationTime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expiration_time</span>
        <span class="k">if</span> <span class="n">enable_remote_replication</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;enableRemoteReplication&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">enable_remote_replication</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyGroupSnapshot&#39;</span><span class="p">,</span>
            <span class="n">ModifyGroupSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.rollback_to_group_snapshot"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.rollback_to_group_snapshot">[docs]</a>    <span class="k">def</span> <span class="nf">rollback_to_group_snapshot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">group_snapshot_id</span><span class="p">,</span>
            <span class="n">save_current_state</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *rollback_to_group_snapshot* is used to roll back each individual</span>
<span class="sd">        volume in a snapshot group to a copy of their individual snapshots.</span>




<span class="sd">        **Note**: Creating a snapshot is allowed if cluster fullness is at</span>
<span class="sd">        stage 2 or 3.</span>
<span class="sd">        Snapshots are not created when cluster fullness is at stage 4 or 5.</span>

<span class="sd">        :param group_snapshot_id: [required] Unique ID of the group snapshot.</span>
<span class="sd">        :type group_snapshot_id: int</span>

<span class="sd">        :param save_current_state: [required]</span>

<span class="sd">            **true**: The previous active volume image is kept.</span>

<span class="sd">            **false**: (default) The previous active volume image is deleted.</span>

<span class="sd">        :type save_current_state: bool</span>

<span class="sd">        :param name: (optional) Name for the snapshot. If no name is given,</span>
<span class="sd">            then the name of the snapshot being rolled back to is used with</span>
<span class="sd">            \&quot;-copy\&quot; appended to the end of the name.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateGroupSnapshotResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;groupSnapshotID&quot;</span><span class="p">:</span> <span class="n">group_snapshot_id</span><span class="p">,</span>
            <span class="s2">&quot;saveCurrentState&quot;</span><span class="p">:</span> <span class="n">save_current_state</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RollbackToGroupSnapshot&#39;</span><span class="p">,</span>
            <span class="n">CreateGroupSnapshotResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_schedule"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_schedule">[docs]</a>    <span class="k">def</span> <span class="nf">get_schedule</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">schedule_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_schedule* is used to return information about a scheduled snapshot</span>
<span class="sd">        that has been created. You can see information about a specified</span>
<span class="sd">        schedule if there are many snapshot schedules in the system. You can</span>
<span class="sd">        include more than one schedule with this method by specifying</span>
<span class="sd">        additional *schedule_ids* to the parameter.</span>

<span class="sd">        :param schedule_id: [required] Unique ID of the schedule or multiple</span>
<span class="sd">            schedules to display</span>
<span class="sd">        :type schedule_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetScheduleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;scheduleID&quot;</span><span class="p">:</span> <span class="n">schedule_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">since</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ElementServiceAdaptor</span><span class="o">.</span><span class="n">get_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                                  <span class="n">since</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_schedules"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_schedules">[docs]</a>    <span class="k">def</span> <span class="nf">list_schedules</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_schedule* is used to return information about all scheduled</span>
<span class="sd">        snapshots that have been created.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListSchedulesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">since</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ElementServiceAdaptor</span><span class="o">.</span><span class="n">list_schedules</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                                    <span class="n">since</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_schedule"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_schedule">[docs]</a>    <span class="k">def</span> <span class="nf">create_schedule</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">schedule</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *create_schedule* is used to create a schedule that will autonomously</span>
<span class="sd">        make a snapshot of a volume at a defined interval.</span>







<span class="sd">        The snapshot created can be used later as a backup or rollback to</span>
<span class="sd">        ensure the data on a volume or group of volumes is consistent for the</span>
<span class="sd">        point in time in which the snapshot was created.</span>







<span class="sd">        **Note**: Creating a snapshot is allowed if cluster fullness is at</span>
<span class="sd">        stage 2 or 3. Snapshots are not created when cluster fullness is at</span>
<span class="sd">        stage 4 or 5.</span>

<span class="sd">        :param schedule: [required] The \&quot;Schedule\&quot; object will be used to</span>
<span class="sd">            create a new schedule.</span>

<span class="sd">            Do not set *schedule_id* property, it will be ignored.</span>

<span class="sd">            Frequency property must be of type that inherits from Frequency.</span>
<span class="sd">            Valid types are:</span>

<span class="sd">            *days_of_month_frequency*</span>

<span class="sd">            *days_or_week_frequency*</span>

<span class="sd">            *time_interval_frequency*</span>

<span class="sd">        :type schedule: Schedule</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateScheduleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;schedule&quot;</span><span class="p">:</span> <span class="n">schedule</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">since</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ElementServiceAdaptor</span><span class="o">.</span><span class="n">create_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                                     <span class="n">since</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_schedule"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_schedule">[docs]</a>    <span class="k">def</span> <span class="nf">modify_schedule</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">schedule</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_schedule* is used to change the intervals at which a scheduled</span>
<span class="sd">        snapshot occurs. This allows for adjustment to the snapshot frequency</span>
<span class="sd">        and retention.</span>




<span class="sd">        :param schedule: [required] The \&quot;Schedule\&quot; object will be used to</span>
<span class="sd">            modify an existing schedule.</span>

<span class="sd">            The *schedule_id* property is required.</span>

<span class="sd">            Frequency property must be of type that inherits from Frequency.</span>
<span class="sd">            Valid types are:</span>

<span class="sd">            *days_of_month_frequency*</span>

<span class="sd">            *days_or_week_frequency*</span>

<span class="sd">            *time_interval_frequency*</span>

<span class="sd">        :type schedule: Schedule</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyScheduleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;schedule&quot;</span><span class="p">:</span> <span class="n">schedule</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">since</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="n">deprecated</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">ElementServiceAdaptor</span><span class="o">.</span><span class="n">modify_schedule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                                     <span class="n">since</span><span class="p">,</span> <span class="n">deprecated</span><span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_raw_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_raw_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_raw_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_raw_stats* call is used by SolidFire engineering to</span>
<span class="sd">        troubleshoot new features. The data returned from *get_raw_stats* is</span>
<span class="sd">        not documented, it changes frequently, and is not guaranteed to be</span>
<span class="sd">        accurate. It is not recommended to ever use *get_raw_stats* for</span>
<span class="sd">        collecting performance data or any other management integration with a</span>
<span class="sd">        SolidFire cluster.</span>
<span class="sd">        The data returned from *get_raw_stats* changes frequently, and is not</span>
<span class="sd">        guaranteed to accurately show performance from the system. It is not</span>
<span class="sd">        recommended to ever use *get_raw_stats* for collecting performance data</span>
<span class="sd">        or any other management integration with a SolidFire cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: Object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetRawStats&#39;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_complete_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_complete_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_complete_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_complete_stats* API method is used by SolidFire engineering to</span>
<span class="sd">        troubleshoot new features. The data returned from *get_complete_stats*</span>
<span class="sd">        is not documented, changes frequently, and is not guaranteed to be</span>
<span class="sd">        accurate. It is not recommended to ever use *get_complete_stats* for</span>
<span class="sd">        collecting performance data or any other management integration with a</span>
<span class="sd">        SolidFire cluster.</span>
<span class="sd">        The data returned from *get_complete_stats* changes frequently, and is</span>
<span class="sd">        not guaranteed to accurately show performance from the system. It is</span>
<span class="sd">        not recommended to ever use *get_complete_stats* for collecting</span>
<span class="sd">        performance data or any other management integration with a SolidFire</span>
<span class="sd">        cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: Object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetCompleteStats&#39;</span><span class="p">,</span>
            <span class="nb">str</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_tests"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_tests">[docs]</a>    <span class="k">def</span> <span class="nf">list_tests</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_tests* API method is used to return the tests that are</span>
<span class="sd">        available to run on a node.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListTestsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListTests&#39;</span><span class="p">,</span>
            <span class="n">ListTestsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_utilities"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_utilities">[docs]</a>    <span class="k">def</span> <span class="nf">list_utilities</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_utilities* API method is used to return the tests that are</span>
<span class="sd">        available to run on a node.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListUtilitiesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListUtilities&#39;</span><span class="p">,</span>
            <span class="n">ListUtilitiesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_connect_ensemble"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_connect_ensemble">[docs]</a>    <span class="k">def</span> <span class="nf">test_connect_ensemble</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ensemble</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_connect_ensemble* API method is used to verify connectivity</span>
<span class="sd">        with a sepcified database ensemble. By default it uses the ensemble for</span>
<span class="sd">        the cluster the node is associated with. Alternatively you can provide</span>
<span class="sd">        a different ensemble to test connectivity with.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :param ensemble: (optional) A comma-separated list of ensemble node</span>
<span class="sd">            *cips* for connectivity testing</span>
<span class="sd">        :type ensemble: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestConnectEnsembleResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">ensemble</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;ensemble&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ensemble</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestConnectEnsemble&#39;</span><span class="p">,</span>
            <span class="n">TestConnectEnsembleResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_connect_mvip"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_connect_mvip">[docs]</a>    <span class="k">def</span> <span class="nf">test_connect_mvip</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mvip</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_connect_mvip* API method is used to test the management</span>
<span class="sd">        connection to the cluster. The test pings the MVIP and executes a</span>
<span class="sd">        simple API method to verify connectivity.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :param mvip: (optional) Optionally, use to test the management</span>
<span class="sd">            connection of a different MVIP. This is not needed to test the</span>
<span class="sd">            connection to the target cluster.</span>
<span class="sd">        :type mvip: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestConnectMvipResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">mvip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;mvip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mvip</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestConnectMvip&#39;</span><span class="p">,</span>
            <span class="n">TestConnectMvipResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_connect_svip"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_connect_svip">[docs]</a>    <span class="k">def</span> <span class="nf">test_connect_svip</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">svip</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_connect_svip* API method is used to test the storage</span>
<span class="sd">        connection to the cluster. The test pings the SVIP using ICMP packets</span>
<span class="sd">        and when successful connects as an iSCSI initiator.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :param svip: (optional) Optionally, use to test the storage connection</span>
<span class="sd">            of a different SVIP. This is not needed to test the connection to</span>
<span class="sd">            the target cluster.</span>
<span class="sd">        :type svip: str</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestConnectSvipResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">svip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;svip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">svip</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestConnectSvip&#39;</span><span class="p">,</span>
            <span class="n">TestConnectSvipResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.test_ping"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.test_ping">[docs]</a>    <span class="k">def</span> <span class="nf">test_ping</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">attempts</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">hosts</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">total_timeout_sec</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">packet_size</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">ping_timeout_msec</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *test_ping* API method is used to validate the connection to all</span>
<span class="sd">        nodes in the cluster on both 1G and 10G interfaces using ICMP packets.</span>
<span class="sd">        The test uses the appropriate MTU sizes for each packet based on the</span>
<span class="sd">        MTU settings in the network configuration.</span>


<span class="sd">            **Note**: This method is available only through the per-node API</span>
<span class="sd">        endpoint 5.0 or later.</span>


<span class="sd">        :param attempts: (optional) Specifies the number of times the system</span>
<span class="sd">            should repeat the test ping. Default is 5.</span>
<span class="sd">        :type attempts: int</span>

<span class="sd">        :param hosts: (optional) Specify address or hostnames of devices to</span>
<span class="sd">            ping.</span>
<span class="sd">        :type hosts: str</span>

<span class="sd">        :param total_timeout_sec: (optional) Specifies the length of time the</span>
<span class="sd">            ping should wait for a system response before issuing the next ping</span>
<span class="sd">            attempt or ending the process.</span>
<span class="sd">        :type total_timeout_sec: int</span>

<span class="sd">        :param packet_size: (optional) Specify the number of bytes to send in</span>
<span class="sd">            the ICMP packet sent to each IP. Number be less than the maximum</span>
<span class="sd">            MTU specified in the network configuration.</span>
<span class="sd">        :type packet_size: int</span>

<span class="sd">        :param ping_timeout_msec: (optional) Specify the number of milliseconds</span>
<span class="sd">            to wait for each individual ping response. Default is 500ms.</span>
<span class="sd">        :type ping_timeout_msec: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: TestPingResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">attempts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attempts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attempts</span>
        <span class="k">if</span> <span class="n">hosts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;hosts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hosts</span>
        <span class="k">if</span> <span class="n">total_timeout_sec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;totalTimeoutSec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_timeout_sec</span>
        <span class="k">if</span> <span class="n">packet_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;packetSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">packet_size</span>
        <span class="k">if</span> <span class="n">ping_timeout_msec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;pingTimeoutMsec&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ping_timeout_msec</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;TestPing&#39;</span><span class="p">,</span>
            <span class="n">TestPingResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_virtual_networks"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_virtual_networks">[docs]</a>    <span class="k">def</span> <span class="nf">list_virtual_networks</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">virtual_network_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tag</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_ids</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tags</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_virtual_networks* is used to get a list of all the configured</span>
<span class="sd">        virtual networks for the cluster. This method can be used to verify the</span>
<span class="sd">        virtual network settings in the cluster.</span>

<span class="sd">        This method does not require any parameters to be passed. But, one or</span>
<span class="sd">        more *virtual_network_ids* or *virtual_network_tags* can be passed in</span>
<span class="sd">        order to filter the results.</span>

<span class="sd">        :param virtual_network_id: (optional) Network ID to filter the list for</span>
<span class="sd">            a single virtual network</span>
<span class="sd">        :type virtual_network_id: int</span>

<span class="sd">        :param virtual_network_tag: (optional) Network Tag to filter the list</span>
<span class="sd">            for a single virtual network</span>
<span class="sd">        :type virtual_network_tag: int</span>

<span class="sd">        :param virtual_network_ids: (optional) *network_ids* to include in the</span>
<span class="sd">            list.</span>
<span class="sd">        :type virtual_network_ids: int[]</span>

<span class="sd">        :param virtual_network_tags: (optional) Network Tags to include in the</span>
<span class="sd">            list.</span>
<span class="sd">        :type virtual_network_tags: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVirtualNetworksResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">virtual_network_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_id</span>
        <span class="k">if</span> <span class="n">virtual_network_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tag</span>
        <span class="k">if</span> <span class="n">virtual_network_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkIDs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_ids</span>
        <span class="k">if</span> <span class="n">virtual_network_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tags</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVirtualNetworks&#39;</span><span class="p">,</span>
            <span class="n">ListVirtualNetworksResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_virtual_network"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_virtual_network">[docs]</a>    <span class="k">def</span> <span class="nf">add_virtual_network</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">virtual_network_tag</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">address_blocks</span><span class="p">,</span>
            <span class="n">netmask</span><span class="p">,</span>
            <span class="n">svip</span><span class="p">,</span>
            <span class="n">gateway</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *add_virtual_network* is used to add a new virtual network to a cluster</span>
<span class="sd">        configuration. When a virtual network is added, an interface for each</span>
<span class="sd">        node is created and each will require a virtual network IP address. The</span>
<span class="sd">        number of IP addresses specified as a parameter for this API method</span>
<span class="sd">        must be equal to or greater than the number of nodes in the cluster.</span>
<span class="sd">        Virtual network addresses are bulk provisioned by SolidFire and</span>
<span class="sd">        assigned to individual nodes automatically. Virtual network addresses</span>
<span class="sd">        do not need to be assigned to nodes manually.</span>




<span class="sd">        **Note:** The *add_virtual_network* method is used only to create a new</span>
<span class="sd">        virtual network. If you want to make changes to a virtual network,</span>
<span class="sd">        please use the *modify_virtual_network* method.</span>

<span class="sd">        :param virtual_network_tag: [required] A unique virtual network (VLAN)</span>
<span class="sd">            tag. Supported values are 1 to 4095 (the number zero (0) is not</span>
<span class="sd">            supported).</span>
<span class="sd">        :type virtual_network_tag: int</span>

<span class="sd">        :param name: [required] User defined name for the new virtual network.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param address_blocks: [required] Unique Range of IP addresses to</span>
<span class="sd">            include in the virtual network. Attributes for this parameter are:</span>

<span class="sd">            **start:** start of the IP address range. (String)</span>

<span class="sd">            **size:** numbre of IP addresses to include in the block. (Integer)</span>

<span class="sd">        :type address_blocks: AddressBlock[]</span>

<span class="sd">        :param netmask: [required] Unique netmask for the virtual network being</span>
<span class="sd">            created.</span>
<span class="sd">        :type netmask: str</span>

<span class="sd">        :param svip: [required] Unique storage IP address for the virtual</span>
<span class="sd">            network being created.</span>
<span class="sd">        :type svip: str</span>

<span class="sd">        :param gateway: (optional)</span>
<span class="sd">        :type gateway: str</span>

<span class="sd">        :param namespace: (optional)</span>
<span class="sd">        :type namespace: bool</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddVirtualNetworkResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;virtualNetworkTag&quot;</span><span class="p">:</span> <span class="n">virtual_network_tag</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;addressBlocks&quot;</span><span class="p">:</span> <span class="n">address_blocks</span><span class="p">,</span>
            <span class="s2">&quot;netmask&quot;</span><span class="p">:</span> <span class="n">netmask</span><span class="p">,</span>
            <span class="s2">&quot;svip&quot;</span><span class="p">:</span> <span class="n">svip</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;add_virtual_network&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;gateway&quot;</span><span class="p">,</span>
                 <span class="n">gateway</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;namespace&quot;</span><span class="p">,</span>
                 <span class="n">namespace</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">gateway</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;gateway&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gateway</span>
        <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddVirtualNetwork&#39;</span><span class="p">,</span>
            <span class="n">AddVirtualNetworkResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_virtual_network"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_virtual_network">[docs]</a>    <span class="k">def</span> <span class="nf">modify_virtual_network</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">virtual_network_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tag</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">address_blocks</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">netmask</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">svip</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">gateway</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">namespace</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_virtual_network* is used to change various attributes of a</span>
<span class="sd">        *virtual_network* object. This method can be used to add or remove</span>
<span class="sd">        address blocks, change the netmask IP, or modify the name or</span>
<span class="sd">        description of the virtual network.</span>




<span class="sd">        **Note:** This method requires either the *virtual_network_id* or the</span>
<span class="sd">        *virtual_network_tag* as a parameter, but not both.</span>

<span class="sd">        :param virtual_network_id: (optional) Unique identifier of the virtual</span>
<span class="sd">            network to modify. This is the virtual network ID assigned by the</span>
<span class="sd">            SolidFire cluster.</span>
<span class="sd">        :type virtual_network_id: int</span>

<span class="sd">        :param virtual_network_tag: (optional) Network Tag that identifies the</span>
<span class="sd">            virtual network to modify.</span>
<span class="sd">        :type virtual_network_tag: int</span>

<span class="sd">        :param name: (optional) New name for the virtual network.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param address_blocks: (optional) New *address_block* to set for this</span>
<span class="sd">            Virtual Network object. This may contain new address blocks to add</span>
<span class="sd">            to the existing object or it may omit unused address blocks that</span>
<span class="sd">            need to be removed. Alternatively, existing address blocks may be</span>
<span class="sd">            extended or reduced in size. The size of the starting</span>
<span class="sd">            *address_blocks* for a Virtual Network object can only be</span>
<span class="sd">            increased, and can never be decreased. Attributes for this</span>
<span class="sd">            parameter are:</span>

<span class="sd">            **start:** start of the IP address range. (String)</span>

<span class="sd">            **size:** numbre of IP addresses to include in the block. (Integer)</span>

<span class="sd">        :type address_blocks: AddressBlock[]</span>

<span class="sd">        :param netmask: (optional) New netmask for this virtual network.</span>
<span class="sd">        :type netmask: str</span>

<span class="sd">        :param svip: (optional) The storage virtual IP address for this virtual</span>
<span class="sd">            network. The svip for Virtual Network cannot be changed. A new</span>
<span class="sd">            Virtual Network must be created in order to use a different svip</span>
<span class="sd">            address.</span>
<span class="sd">        :type svip: str</span>

<span class="sd">        :param gateway: (optional)</span>
<span class="sd">        :type gateway: str</span>

<span class="sd">        :param namespace: (optional)</span>
<span class="sd">        :type namespace: bool</span>

<span class="sd">        :param attributes: (optional) A new list of Name/Value pairs in JSON</span>
<span class="sd">            object format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: AddVirtualNetworkResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;modify_virtual_network&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;gateway&quot;</span><span class="p">,</span>
                 <span class="n">gateway</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;namespace&quot;</span><span class="p">,</span>
                 <span class="n">namespace</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_network_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_id</span>
        <span class="k">if</span> <span class="n">virtual_network_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tag</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">address_blocks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;addressBlocks&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">address_blocks</span>
        <span class="k">if</span> <span class="n">netmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;netmask&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">netmask</span>
        <span class="k">if</span> <span class="n">svip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;svip&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">svip</span>
        <span class="k">if</span> <span class="n">gateway</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;gateway&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gateway</span>
        <span class="k">if</span> <span class="n">namespace</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;namespace&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">namespace</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyVirtualNetwork&#39;</span><span class="p">,</span>
            <span class="n">AddVirtualNetworkResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_virtual_network"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_virtual_network">[docs]</a>    <span class="k">def</span> <span class="nf">remove_virtual_network</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">virtual_network_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tag</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *remove_virtual_network* is used to remove a previously added virtual</span>
<span class="sd">        network.</span>




<span class="sd">        **Note:** This method requires either the *virtual_network_id* of the</span>
<span class="sd">        *virtual_network_tag* as a parameter, but not both.</span>

<span class="sd">        :param virtual_network_id: (optional) Network ID that identifies the</span>
<span class="sd">            virtual network to remove.</span>
<span class="sd">        :type virtual_network_id: int</span>

<span class="sd">        :param virtual_network_tag: (optional) Network Tag that identifies the</span>
<span class="sd">            virtual network to remove.</span>
<span class="sd">        :type virtual_network_tag: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RemoveVirtualNetworkResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">virtual_network_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_id</span>
        <span class="k">if</span> <span class="n">virtual_network_tag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tag</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveVirtualNetwork&#39;</span><span class="p">,</span>
            <span class="n">RemoveVirtualNetworkResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.clone_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.clone_volume">[docs]</a>    <span class="k">def</span> <span class="nf">clone_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">new_account_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">new_size</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">access</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *clone_volume* is used to create a copy of the volume.</span>
<span class="sd">        This method is asynchronous and may take a variable amount of time to</span>
<span class="sd">        complete.</span>
<span class="sd">        The cloning process begins immediately when the *clone_volume* request</span>
<span class="sd">        is made and is representative of the state of the volume when the API</span>
<span class="sd">        method is issued.</span>
<span class="sd">        *get_async_results* can be used to determine when the cloning process</span>
<span class="sd">        is complete and the new volume is available for connections.</span>
<span class="sd">        *list_sync_jobs* can be used to see the progress of creating the clone.</span>




<span class="sd">        **Note**: The initial attributes and quality of service settings for</span>
<span class="sd">        the volume are inherited from the volume being cloned.</span>
<span class="sd">        If different settings are required, they can be changed via</span>
<span class="sd">        ModifyVolume.</span>




<span class="sd">        **Note**: Cloned volumes do not inherit volume access group memberships</span>
<span class="sd">        from the source volume.</span>

<span class="sd">        :param volume_id: [required] The ID of the volume to clone.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param name: [required] The name for the newly-created volume.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param new_account_id: (optional) *account_id* for the owner of the new</span>
<span class="sd">            volume. If unspecified, the *account_id* of the owner of the volume</span>
<span class="sd">            being cloned is used.</span>
<span class="sd">        :type new_account_id: int</span>

<span class="sd">        :param new_size: (optional) New size of the volume, in bytes. May be</span>
<span class="sd">            greater or less than the size of the volume being cloned. If</span>
<span class="sd">            unspecified, the clone&#39;s volume size will be the same as the source</span>
<span class="sd">            volume. Size is rounded up to the nearest 1 MiB.</span>
<span class="sd">        :type new_size: int</span>

<span class="sd">        :param access: (optional) Access settings for the new volume.</span>

<span class="sd">            **readOnly**: Only read operations are allowed.</span>

<span class="sd">            **readWrite**: Reads and writes are allowed.</span>

<span class="sd">            **locked**: No reads or writes are allowed.</span>

<span class="sd">            **replicationTarget**: Identify a volume as the target volume for a</span>
<span class="sd">            paired set of volumes. If the volume is not paired, the access</span>
<span class="sd">            status is locked.</span>

<span class="sd">            If unspecified, the access settings of the clone will be the same</span>
<span class="sd">            as the source.</span>

<span class="sd">        :type access: str</span>

<span class="sd">        :param snapshot_id: (optional) ID of the snapshot to use as the source</span>
<span class="sd">            of the clone. If unspecified, the clone will be created with a</span>
<span class="sd">            snapshot of the active volume.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CloneVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">new_account_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;newAccountID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_account_id</span>
        <span class="k">if</span> <span class="n">new_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;newSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_size</span>
        <span class="k">if</span> <span class="n">access</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;access&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span>
        <span class="k">if</span> <span class="n">snapshot_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;snapshotID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot_id</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CloneVolume&#39;</span><span class="p">,</span>
            <span class="n">CloneVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.clone_multiple_volumes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.clone_multiple_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">clone_multiple_volumes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volumes</span><span class="p">,</span>
            <span class="n">access</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">group_snapshot_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">new_account_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *clone_multiple_volumes* is used to create a clone of a group of</span>
<span class="sd">        specified volumes. A consistent set of characteristics can be assigned</span>
<span class="sd">        to a group of multiple volume when they are cloned together.</span>
<span class="sd">        If *group_snapshot_id* is going to be used to clone the volumes in a</span>
<span class="sd">        group snapshot, the group snapshot must be created first using the</span>
<span class="sd">        *create_group_snapshot* API method or the SolidFire Element WebUI.</span>
<span class="sd">        Using *group_snapshot_id* is optional when cloning multiple volumes.</span>




<span class="sd">        **Note**: Cloning multiple volumes is allowed if cluster fullness is at</span>
<span class="sd">        stage 2 or 3. Clones are not created when cluster fullness is at stage</span>
<span class="sd">        4 or 5.</span>

<span class="sd">        :param volumes: [required] Array of Unique ID for each volume to</span>
<span class="sd">            include in the clone with optional parameters. If optional</span>
<span class="sd">            parameters are not specified, the values will be inherited from the</span>
<span class="sd">            source volumes.</span>
<span class="sd">        :type volumes: CloneMultipleVolumeParams[]</span>

<span class="sd">        :param access: (optional) New default access method for the new volumes</span>
<span class="sd">            if not overridden by information passed in the volumes array.</span>

<span class="sd">            **readOnly**: Only read operations are allowed.</span>

<span class="sd">            **readWrite**: Reads and writes are allowed.</span>

<span class="sd">            **locked**: No reads or writes are allowed.</span>

<span class="sd">            **replicationTarget**: Identify a volume as the target volume for a</span>
<span class="sd">            paired set of volumes. If the volume is not paired, the access</span>
<span class="sd">            status is locked.</span>

<span class="sd">            If unspecified, the access settings of the clone will be the same</span>
<span class="sd">            as the source.</span>

<span class="sd">        :type access: str</span>

<span class="sd">        :param group_snapshot_id: (optional) ID of the group snapshot to use as</span>
<span class="sd">            a basis for the clone.</span>
<span class="sd">        :type group_snapshot_id: int</span>

<span class="sd">        :param new_account_id: (optional) New account ID for the volumes if not</span>
<span class="sd">            overridden by information passed in the volumes array.</span>
<span class="sd">        :type new_account_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CloneMultipleVolumesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumes&quot;</span><span class="p">:</span> <span class="n">volumes</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">access</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;access&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span>
        <span class="k">if</span> <span class="n">group_snapshot_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;groupSnapshotID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_snapshot_id</span>
        <span class="k">if</span> <span class="n">new_account_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;newAccountID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_account_id</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CloneMultipleVolumes&#39;</span><span class="p">,</span>
            <span class="n">CloneMultipleVolumesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_volume">[docs]</a>    <span class="k">def</span> <span class="nf">create_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,</span>
            <span class="n">total_size</span><span class="p">,</span>
            <span class="n">enable512e</span><span class="p">,</span>
            <span class="n">qos</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *create_volume* is used to create a new (empty) volume on the cluster.</span>
<span class="sd">        When the volume is created successfully it is available for connection</span>
<span class="sd">        via iSCSI.</span>

<span class="sd">        :param name: [required] Name of the volume. Not required to be unique,</span>
<span class="sd">            but it is recommended. May be 1 to 64 characters in length.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param account_id: [required] *account_id* for the owner of this</span>
<span class="sd">            volume.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :param total_size: [required] Total size of the volume, in bytes. Size</span>
<span class="sd">            is rounded up to the nearest 1MB size.</span>
<span class="sd">        :type total_size: int</span>

<span class="sd">        :param enable512e: [required] Should the volume provides 512-byte</span>
<span class="sd">            sector emulation?</span>
<span class="sd">        :type enable512e: bool</span>

<span class="sd">        :param qos: (optional) Initial quality of service settings for this</span>
<span class="sd">            volume.</span>

<span class="sd">            Volumes created without specified *qos* values are created with the</span>
<span class="sd">            default values for QoS. Default values for a volume can be found by</span>
<span class="sd">            running the *get_default_qos* method.</span>

<span class="sd">        :type qos: QoS</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
            <span class="s2">&quot;totalSize&quot;</span><span class="p">:</span> <span class="n">total_size</span><span class="p">,</span>
            <span class="s2">&quot;enable512e&quot;</span><span class="p">:</span> <span class="n">enable512e</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">qos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;qos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qos</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CreateVolume&#39;</span><span class="p">,</span>
            <span class="n">CreateVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.delete_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.delete_volume">[docs]</a>    <span class="k">def</span> <span class="nf">delete_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *delete_volume* marks an active volume for deletion.</span>
<span class="sd">        It is purged (permanently deleted) after the cleanup interval elapses.</span>
<span class="sd">        After making a request to delete a volume, any active iSCSI connections</span>
<span class="sd">        to the volume is immediately terminated and no further connections are</span>
<span class="sd">        allowed while the volume is in this state.</span>
<span class="sd">        It is not returned in target discovery requests.</span>




<span class="sd">        Any snapshots of a volume that has been marked to delete are not</span>
<span class="sd">        affected.</span>
<span class="sd">        Snapshots are kept until the volume is purged from the system.</span>




<span class="sd">        If a volume is marked for deletion, and it has a bulk volume read or</span>
<span class="sd">        bulk volume write operation in progress, the bulk volume operation is</span>
<span class="sd">        stopped.</span>




<span class="sd">        If the volume you delete is paired with a volume, replication between</span>
<span class="sd">        the paired volumes is suspended and no data is transferred to it or</span>
<span class="sd">        from it while in a deleted state.</span>
<span class="sd">        The remote volume the deleted volume was paired with enters into a</span>
<span class="sd">        *paused_misconfigured* state and data is no longer sent to it or from</span>
<span class="sd">        the deleted volume.</span>
<span class="sd">        Until the deleted volume is purged, it can be restored and data</span>
<span class="sd">        transfers resumes.</span>
<span class="sd">        If the deleted volume gets purged from the system, the volume it was</span>
<span class="sd">        paired with enters into a *stopped_misconfigured* state and the volume</span>
<span class="sd">        pairing status is removed.</span>
<span class="sd">        The purged volume becomes permanently unavailable.</span>

<span class="sd">        :param volume_id: [required] The ID of the volume to delete.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DeleteVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DeleteVolume&#39;</span><span class="p">,</span>
            <span class="n">DeleteVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_volume_stats"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_volume_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_volume_stats</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_volume_stats* is used to retrieve high-level activity measurements</span>
<span class="sd">        for a single volume.</span>
<span class="sd">        Values are cumulative from the creation of the volume.</span>

<span class="sd">        :param volume_id: [required] Specifies the volume for which statistics</span>
<span class="sd">            is gathered.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetVolumeStatsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetVolumeStats&#39;</span><span class="p">,</span>
            <span class="n">GetVolumeStatsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_volume_efficiency"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_volume_efficiency">[docs]</a>    <span class="k">def</span> <span class="nf">get_volume_efficiency</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">force</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_volume_efficiency* is used to retrieve information about a volume.</span>
<span class="sd">        Only the volume given as a parameter in this API method is used to</span>
<span class="sd">        compute the capacity.</span>

<span class="sd">        :param volume_id: [required] Specifies the volume for which capacity is</span>
<span class="sd">            computed.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param force: (optional)</span>
<span class="sd">        :type force: bool</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetVolumeEfficiencyResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">force</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;force&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">force</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetVolumeEfficiency&#39;</span><span class="p">,</span>
            <span class="n">GetVolumeEfficiencyResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_bulk_volume_jobs"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_bulk_volume_jobs">[docs]</a>    <span class="k">def</span> <span class="nf">list_bulk_volume_jobs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_bulk_volume_jobs* is used to return information about each bulk</span>
<span class="sd">        volume read or write operation that is occurring in the system.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListBulkVolumeJobsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListBulkVolumeJobs&#39;</span><span class="p">,</span>
            <span class="n">ListBulkVolumeJobsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_active_volumes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_active_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">list_active_volumes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_volume_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_active_volumes* is used to return the list of active volumes</span>
<span class="sd">        currently in the system.</span>
<span class="sd">        The list of volumes is returned sorted in *volume_id* order and can be</span>
<span class="sd">        returned in multiple parts (pages).</span>

<span class="sd">        :param start_volume_id: (optional) The ID of the first volume to list.</span>
<span class="sd">            This can be useful for paging results. By default, this starts at</span>
<span class="sd">            the lowest VolumeID.</span>
<span class="sd">        :type start_volume_id: int</span>

<span class="sd">        :param limit: (optional) The maximum number of volumes to return from</span>
<span class="sd">            the API.</span>
<span class="sd">        :type limit: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListActiveVolumesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">start_volume_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startVolumeID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_volume_id</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListActiveVolumes&#39;</span><span class="p">,</span>
            <span class="n">ListActiveVolumesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_deleted_volumes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_deleted_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">list_deleted_volumes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_deleted_volumes* is used to return the entire list of volumes</span>
<span class="sd">        that have been marked for deletion and is purged from the system.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListDeletedVolumesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListDeletedVolumes&#39;</span><span class="p">,</span>
            <span class="n">ListDeletedVolumesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_iscsisessions"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_iscsisessions">[docs]</a>    <span class="k">def</span> <span class="nf">list_iscsisessions</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_iscsisessions* is used to return iSCSI connection information for</span>
<span class="sd">        volumes in the cluster.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListISCSISessionsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListISCSISessions&#39;</span><span class="p">,</span>
            <span class="n">ListISCSISessionsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volumes"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volumes">[docs]</a>    <span class="k">def</span> <span class="nf">list_volumes</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_volume_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">volume_status</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">accounts</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">is_paired</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">volume_ids</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *list_volumes* method is used to return a list of volumes that are</span>
<span class="sd">        in a cluster.</span>
<span class="sd">        You can specify the volumes you want to return in the list by using the</span>
<span class="sd">        available parameters.</span>

<span class="sd">        :param start_volume_id: (optional) The ID of the first volume to list.</span>
<span class="sd">            This can be useful for paging results. By default, this starts at</span>
<span class="sd">            the lowest VolumeID.</span>
<span class="sd">        :type start_volume_id: int</span>

<span class="sd">        :param limit: (optional) The maximum number of volumes to return from</span>
<span class="sd">            the API.</span>
<span class="sd">        :type limit: int</span>

<span class="sd">        :param volume_status: (optional) If specified, filter to only volumes</span>
<span class="sd">            with the provided status. By default, list all volumes.</span>
<span class="sd">        :type volume_status: str</span>

<span class="sd">        :param accounts: (optional) If specified, only fetch volumes which</span>
<span class="sd">            belong to the provided accounts. By default, list volumes for all</span>
<span class="sd">            accounts.</span>
<span class="sd">        :type accounts: int[]</span>

<span class="sd">        :param is_paired: (optional) If specified, only fetch volumes which are</span>
<span class="sd">            paired (if true) or non-paired (if false). By default, list all</span>
<span class="sd">            volumes regardless of their pairing status.</span>
<span class="sd">        :type is_paired: bool</span>

<span class="sd">        :param volume_ids: (optional) If specified, only fetch volumes</span>
<span class="sd">            specified in this list. This option cannot be specified if</span>
<span class="sd">            *start_volume_id,* limit, or accounts option is specified.</span>
<span class="sd">        :type volume_ids: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumesResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;list_volumes&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;volume_ids&quot;</span><span class="p">,</span>
                 <span class="n">volume_ids</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">start_volume_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startVolumeID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_volume_id</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>
        <span class="k">if</span> <span class="n">volume_status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumeStatus&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_status</span>
        <span class="k">if</span> <span class="n">accounts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;accounts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">accounts</span>
        <span class="k">if</span> <span class="n">is_paired</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;isPaired&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_paired</span>
        <span class="k">if</span> <span class="n">volume_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumeIDs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_ids</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumes&#39;</span><span class="p">,</span>
            <span class="n">ListVolumesResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">since</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volumes_for_account"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volumes_for_account">[docs]</a>    <span class="k">def</span> <span class="nf">list_volumes_for_account</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">account_id</span><span class="p">,</span>
            <span class="n">start_volume_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_volumes_for_account* returns the list of active AND (pending)</span>
<span class="sd">        deleted volumes for an account.</span>

<span class="sd">        :param account_id: [required] The ID of the account to list the volumes</span>
<span class="sd">            for.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :param start_volume_id: (optional) The ID of the first volume to list.</span>
<span class="sd">            This can be useful for paging results. By default, this starts at</span>
<span class="sd">            the lowest VolumeID.</span>
<span class="sd">        :type start_volume_id: int</span>

<span class="sd">        :param limit: (optional) The maximum number of volumes to return from</span>
<span class="sd">            the API.</span>
<span class="sd">        :type limit: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumesForAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;accountID&quot;</span><span class="p">:</span> <span class="n">account_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">start_volume_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startVolumeID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_volume_id</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumesForAccount&#39;</span><span class="p">,</span>
            <span class="n">ListVolumesForAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">deprecated</span><span class="o">=</span><span class="mf">8.0</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volume_stats_by_account"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volume_stats_by_account">[docs]</a>    <span class="k">def</span> <span class="nf">list_volume_stats_by_account</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_volume_stats_by_account* returns high-level activity measurements</span>
<span class="sd">        for every account.</span>
<span class="sd">        Values are summed from all the volumes owned by the account.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumeStatsByAccountResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumeStatsByAccount&#39;</span><span class="p">,</span>
            <span class="n">ListVolumeStatsByAccountResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volume_stats_by_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volume_stats_by_volume">[docs]</a>    <span class="k">def</span> <span class="nf">list_volume_stats_by_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_volume_stats_by_volume* returns high-level activity measurements</span>
<span class="sd">        for every volume, by volume.</span>
<span class="sd">        Values are cumulative from the creation of the volume.</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumeStatsByVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumeStatsByVolume&#39;</span><span class="p">,</span>
            <span class="n">ListVolumeStatsByVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volume_stats_by_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volume_stats_by_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">list_volume_stats_by_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_groups</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_volume_stats_by_volume_access_group* is used to get total</span>
<span class="sd">        activity measurements for all of the volumes that are a member of the</span>
<span class="sd">        specified volume access group(s).</span>

<span class="sd">        :param volume_access_groups: (optional) An array of</span>
<span class="sd">            *volume_access_group_ids* for which volume activity is returned. If</span>
<span class="sd">            no *volume_access_group_id* is specified, stats for all volume</span>
<span class="sd">            access groups is returned.</span>
<span class="sd">        :type volume_access_groups: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumeStatsByVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">volume_access_groups</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumeAccessGroups&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume_access_groups</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumeStatsByVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ListVolumeStatsByVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_volume">[docs]</a>    <span class="k">def</span> <span class="nf">modify_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="n">account_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">access</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">set_create_time</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">qos</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">total_size</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *modify_volume* is used to modify settings on an existing volume.</span>
<span class="sd">        Modifications can be made to one volume at a time and changes take</span>
<span class="sd">        place immediately.</span>
<span class="sd">        If an optional parameter is left unspecified, the value will not be</span>
<span class="sd">        changed.</span>




<span class="sd">        Extending the size of a volume that is being replicated should be done</span>
<span class="sd">        in an order.</span>
<span class="sd">        The target (Replication Target) volume should first be increased in</span>
<span class="sd">        size, then the source (Read/Write) volume can be resized.</span>
<span class="sd">        It is recommended that both the target and the source volumes be the</span>
<span class="sd">        same size.</span>




<span class="sd">        **Note**: If you change access status to locked or target all existing</span>
<span class="sd">        iSCSI connections are terminated.</span>

<span class="sd">        :param volume_id: [required] *volume_id* for the volume to be modified.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param account_id: (optional) *account_id* to which the volume is</span>
<span class="sd">            reassigned. If none is specified, the previous account name is</span>
<span class="sd">            used.</span>
<span class="sd">        :type account_id: int</span>

<span class="sd">        :param access: (optional) Access allowed for the volume.</span>

<span class="sd">            **readOnly**: Only read operations are allowed.</span>

<span class="sd">            **readWrite**: Reads and writes are allowed.</span>

<span class="sd">            **locked**: No reads or writes are allowed.</span>

<span class="sd">            **replicationTarget**: Identify a volume as the target volume for a</span>
<span class="sd">            paired set of volumes. If the volume is not paired, the access</span>
<span class="sd">            status is locked.</span>

<span class="sd">            If unspecified, the access settings of the clone will be the same</span>
<span class="sd">            as the source.</span>

<span class="sd">        :type access: str</span>

<span class="sd">        :param set_create_time: (optional) Identify the time at which the</span>
<span class="sd">            volume was created.</span>
<span class="sd">        :type set_create_time: str</span>

<span class="sd">        :param qos: (optional) New quality of service settings for this volume.</span>
<span class="sd">        :type qos: QoS</span>

<span class="sd">        :param total_size: (optional) New size of the volume in bytes. Size is</span>
<span class="sd">            rounded up to the nearest 1MiB size. This parameter can only be</span>
<span class="sd">            used to *increase* the size of a volume.</span>
<span class="sd">        :type total_size: int</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">account_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;accountID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">account_id</span>
        <span class="k">if</span> <span class="n">access</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;access&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">access</span>
        <span class="k">if</span> <span class="n">set_create_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;setCreateTime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">set_create_time</span>
        <span class="k">if</span> <span class="n">qos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;qos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qos</span>
        <span class="k">if</span> <span class="n">total_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;totalSize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_size</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyVolume&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.purge_deleted_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.purge_deleted_volume">[docs]</a>    <span class="k">def</span> <span class="nf">purge_deleted_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *purge_deleted_volume* immediately and permanently purges a volume</span>
<span class="sd">        which has been deleted.</span>
<span class="sd">        A volume must be deleted using *delete_volume* before it can be purged.</span>
<span class="sd">        Volumes are purged automatically after a period of time, so usage of</span>
<span class="sd">        this method is not typically required.</span>

<span class="sd">        :param volume_id: [required] The ID of the volume to purge.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: PurgeDeletedVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;PurgeDeletedVolume&#39;</span><span class="p">,</span>
            <span class="n">PurgeDeletedVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.restore_deleted_volume"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.restore_deleted_volume">[docs]</a>    <span class="k">def</span> <span class="nf">restore_deleted_volume</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *restore_deleted_volume* marks a deleted volume as active again.</span>
<span class="sd">        This action makes the volume immediately available for iSCSI</span>
<span class="sd">        connection.</span>

<span class="sd">        :param volume_id: [required] *volume_id* for the deleted volume to</span>
<span class="sd">            restore.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: RestoreDeletedVolumeResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RestoreDeletedVolume&#39;</span><span class="p">,</span>
            <span class="n">RestoreDeletedVolumeResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.start_bulk_volume_read"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.start_bulk_volume_read">[docs]</a>    <span class="k">def</span> <span class="nf">start_bulk_volume_read</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="nb">format</span><span class="p">,</span>
            <span class="n">snapshot_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">script</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">script_parameters</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *start_bulk_volume_read* allows you to initialize a bulk volume read</span>
<span class="sd">        session on a specified volume.</span>
<span class="sd">        Only two bulk volume processes can run simultaneously on a volume.</span>
<span class="sd">        When you initialize the session, data is read from a SolidFire storage</span>
<span class="sd">        volume for the purposes of storing the data on an external backup</span>
<span class="sd">        source.</span>
<span class="sd">        The external data is accessed by a web server running on a SolidFire</span>
<span class="sd">        node.</span>
<span class="sd">        Communications and server interaction information for external data</span>
<span class="sd">        access is passed by a script running on the SolidFire storage system.</span>







<span class="sd">        At the start of a bulk volume read operation, a snapshot of the volume</span>
<span class="sd">        is made and the snapshot is deleted when the read has completed.</span>
<span class="sd">        You can also read a snapshot of the volume by entering the ID of the</span>
<span class="sd">        snapshot as a parameter.</span>
<span class="sd">        Reading a previous snapshot does not create a new snapshot of the</span>
<span class="sd">        volume, nor does the previous snapshot be deleted when the read</span>
<span class="sd">        completes.</span>







<span class="sd">        **Note**: This process creates a new snapshot if the ID of an existing</span>
<span class="sd">        snapshot is not provided.</span>
<span class="sd">        Snapshots can be created if cluster fullness is at stage 2 or 3.</span>
<span class="sd">        Snapshots are not created when cluster fullness is at stage 4 or 5.</span>

<span class="sd">        :param volume_id: [required] ID of the volume to be read.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param format: [required] The format of the volume data. Can be either:</span>

<span class="sd">            **uncompressed**: every byte of the volume is returned without any</span>
<span class="sd">            compression.</span>

<span class="sd">            **native**: opaque data is returned that is smaller and more</span>
<span class="sd">            efficiently stored and written on a subsequent bulk volume write.</span>

<span class="sd">        :type format: str</span>

<span class="sd">        :param snapshot_id: (optional) ID of a previously created snapshot used</span>
<span class="sd">            for bulk volume reads. If no ID is entered, a snapshot of the</span>
<span class="sd">            current active volume image is made.</span>
<span class="sd">        :type snapshot_id: int</span>

<span class="sd">        :param script: (optional) Executable name of a script. If no script</span>
<span class="sd">            name is given then the key and URL is necessary to access SolidFire</span>
<span class="sd">            nodes. The script is run on the primary node and the key and URL is</span>
<span class="sd">            returned to the script so the local web server can be contacted.</span>
<span class="sd">        :type script: str</span>

<span class="sd">        :param script_parameters: (optional) JSON parameters to pass to the</span>
<span class="sd">            script.</span>
<span class="sd">        :type script_parameters: str</span>

<span class="sd">        :param attributes: (optional) JSON attributes for the bulk volume job.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: StartBulkVolumeReadResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="nb">format</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">snapshot_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;snapshotID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot_id</span>
        <span class="k">if</span> <span class="n">script</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;script&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">script</span>
        <span class="k">if</span> <span class="n">script_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;scriptParameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">script_parameters</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;StartBulkVolumeRead&#39;</span><span class="p">,</span>
            <span class="n">StartBulkVolumeReadResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.start_bulk_volume_write"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.start_bulk_volume_write">[docs]</a>    <span class="k">def</span> <span class="nf">start_bulk_volume_write</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_id</span><span class="p">,</span>
            <span class="nb">format</span><span class="p">,</span>
            <span class="n">script</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">script_parameters</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *start_bulk_volume_write* allows you to initialize a bulk volume write</span>
<span class="sd">        session on a specified volume.</span>
<span class="sd">        Only two bulk volume processes can run simultaneously on a volume.</span>
<span class="sd">        When the session is initialized, data can be written to a SolidFire</span>
<span class="sd">        storage volume from an external backup source.</span>
<span class="sd">        The external data is accessed by a web server running on a SolidFire</span>
<span class="sd">        node.</span>
<span class="sd">        Communications and server interaction information for external data</span>
<span class="sd">        access is passed by a script running on the SolidFire storage system.</span>

<span class="sd">        :param volume_id: [required] ID of the volume to be written to.</span>
<span class="sd">        :type volume_id: int</span>

<span class="sd">        :param format: [required] The format of the volume data. Can be either:</span>

<span class="sd">            **uncompressed**: every byte of the volume is returned without any</span>
<span class="sd">            compression.</span>

<span class="sd">            **native**: opaque data is returned that is smaller and more</span>
<span class="sd">            efficiently stored and written on a subsequent bulk volume write</span>

<span class="sd">        :type format: str</span>

<span class="sd">        :param script: (optional) Executable name of a script. If no script</span>
<span class="sd">            name is given then the key and URL are necessary to access</span>
<span class="sd">            SolidFire nodes. The script runs on the primary node and the key</span>
<span class="sd">            and URL is returned to the script so the local web server can be</span>
<span class="sd">            contacted.</span>
<span class="sd">        :type script: str</span>

<span class="sd">        :param script_parameters: (optional) JSON parameters to pass to the</span>
<span class="sd">            script.</span>
<span class="sd">        :type script_parameters: str</span>

<span class="sd">        :param attributes: (optional) JSON attributes for the bulk volume job.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: StartBulkVolumeWriteResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeID&quot;</span><span class="p">:</span> <span class="n">volume_id</span><span class="p">,</span>
            <span class="s2">&quot;format&quot;</span><span class="p">:</span> <span class="nb">format</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">script</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;script&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">script</span>
        <span class="k">if</span> <span class="n">script_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;scriptParameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">script_parameters</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;StartBulkVolumeWrite&#39;</span><span class="p">,</span>
            <span class="n">StartBulkVolumeWriteResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.update_bulk_volume_status"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.update_bulk_volume_status">[docs]</a>    <span class="k">def</span> <span class="nf">update_bulk_volume_status</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">status</span><span class="p">,</span>
            <span class="n">percent_complete</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        You can use *update_bulk_volume_status* in a script to return to the</span>
<span class="sd">        SolidFire system the status of a bulk volume job that you have started</span>
<span class="sd">        with the *\&quot;start_bulk_volume_read\&quot;* or *\&quot;start_bulk_volume_write\&quot;*</span>
<span class="sd">        methods.</span>

<span class="sd">        :param key: [required] The key assigned during initialization of a</span>
<span class="sd">            \&quot;StartBulkVolumeRead\&quot; or \&quot;StartBulkVolumeWrite\&quot; session.</span>
<span class="sd">        :type key: str</span>

<span class="sd">        :param status: [required] The SolidFire system sets the status of the</span>
<span class="sd">            given bulk volume job.</span>

<span class="sd">            Possible values:</span>



<span class="sd">            **running**: jobs that are still active.</span>

<span class="sd">            **complete**: jobs that are done. failed - jobs that have failed.</span>

<span class="sd">            **failed**: jobs that have failed.</span>

<span class="sd">        :type status: str</span>

<span class="sd">        :param percent_complete: (optional) The completed progress of the bulk</span>
<span class="sd">            volume job as a percentage.</span>
<span class="sd">        :type percent_complete: str</span>

<span class="sd">        :param message: (optional) Returns the status of the bulk volume job</span>
<span class="sd">            when the job has completed.</span>
<span class="sd">        :type message: str</span>

<span class="sd">        :param attributes: (optional) JSON attributes  updates what is on the</span>
<span class="sd">            bulk volume job.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: UpdateBulkVolumeStatusResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
            <span class="s2">&quot;status&quot;</span><span class="p">:</span> <span class="n">status</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">percent_complete</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;percentComplete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">percent_complete</span>
        <span class="k">if</span> <span class="n">message</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;message&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">message</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;UpdateBulkVolumeStatus&#39;</span><span class="p">,</span>
            <span class="n">UpdateBulkVolumeStatusResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.create_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.create_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">create_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">,</span>
            <span class="n">initiators</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">volumes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tags</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new volume access group.</span>
<span class="sd">        The new volume access group must be given a name when it is created.</span>
<span class="sd">        Entering initiators and volumes are optional when creating a volume</span>
<span class="sd">        access group.</span>
<span class="sd">        Once the group is created volumes and initiator IQNs can be added.</span>
<span class="sd">        Any initiator IQN that is successfully added to the volume access group</span>
<span class="sd">        is able to access any volume in the group without CHAP authentication.</span>

<span class="sd">        :param name: [required] Name of the volume access group. It is not</span>
<span class="sd">            required to be unique, but recommended.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param initiators: (optional) List of initiators to include in the</span>
<span class="sd">            volume access group. If unspecified, the access group will start</span>
<span class="sd">            out without configured initiators.</span>
<span class="sd">        :type initiators: str[]</span>

<span class="sd">        :param volumes: (optional) List of volumes to initially include in the</span>
<span class="sd">            volume access group. If unspecified, the access group will start</span>
<span class="sd">            without any volumes.</span>
<span class="sd">        :type volumes: int[]</span>

<span class="sd">        :param virtual_network_id: (optional) The ID of the SolidFire Virtual</span>
<span class="sd">            Network ID to associate the volume access group with.</span>
<span class="sd">        :type virtual_network_id: int[]</span>

<span class="sd">        :param virtual_network_tags: (optional) The ID of the VLAN Virtual</span>
<span class="sd">            Network Tag to associate the volume access group with.</span>
<span class="sd">        :type virtual_network_tags: int[]</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: CreateVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;create_volume_access_group&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;virtual_network_id&quot;</span><span class="p">,</span>
                 <span class="n">virtual_network_id</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;virtual_network_tags&quot;</span><span class="p">,</span>
                 <span class="n">virtual_network_tags</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">initiators</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;initiators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initiators</span>
        <span class="k">if</span> <span class="n">volumes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volumes</span>
        <span class="k">if</span> <span class="n">virtual_network_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_id</span>
        <span class="k">if</span> <span class="n">virtual_network_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tags</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;CreateVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">CreateVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.list_volume_access_groups"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.list_volume_access_groups">[docs]</a>    <span class="k">def</span> <span class="nf">list_volume_access_groups</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">start_volume_access_group_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *list_volume_access_groups* is used to return information about the</span>
<span class="sd">        volume access groups that are currently in the system.</span>

<span class="sd">        :param start_volume_access_group_id: (optional) The lowest</span>
<span class="sd">            *volume_access_group_id* to return. This can be useful for paging.</span>
<span class="sd">            If unspecified, there is no lower limit (implicitly 0).</span>
<span class="sd">        :type start_volume_access_group_id: int</span>

<span class="sd">        :param limit: (optional) The maximum number of results to return. This</span>
<span class="sd">            can be useful for paging.</span>
<span class="sd">        :type limit: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ListVolumeAccessGroupsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">start_volume_access_group_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;startVolumeAccessGroupID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_volume_access_group_id</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">limit</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ListVolumeAccessGroups&#39;</span><span class="p">,</span>
            <span class="n">ListVolumeAccessGroupsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.delete_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.delete_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">delete_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a volume access group from the system.</span>

<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to delete.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: DeleteVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;DeleteVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">DeleteVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">modify_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">virtual_network_id</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">virtual_network_tags</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">initiators</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">volumes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,</span>
            <span class="n">attributes</span><span class="o">=</span><span class="n">OPTIONAL</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update initiators and add or remove volumes from a volume access group.</span>
<span class="sd">        A specified initiator or volume that duplicates an existing volume or</span>
<span class="sd">        initiator in a volume access group is left as-is.</span>
<span class="sd">        If a value is not specified for volumes or initiators, the current list</span>
<span class="sd">        of initiators and volumes are not changed.</span>




<span class="sd">        Often, it is easier to use the convenience functions to modify</span>
<span class="sd">        initiators and volumes independently:</span>




<span class="sd">        *add_initiators_to_volume_access_group*</span>



<span class="sd">        *remove_initiators_from_volume_access_group*</span>



<span class="sd">        *add_volumes_to_volume_access_group*</span>



<span class="sd">        *remove_volumes_from_volume_access_group*</span>




<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to modify.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param virtual_network_id: (optional) The ID of the SolidFire Virtual</span>
<span class="sd">            Network ID to associate the volume access group with.</span>
<span class="sd">        :type virtual_network_id: int[]</span>

<span class="sd">        :param virtual_network_tags: (optional) The ID of the VLAN Virtual</span>
<span class="sd">            Network Tag to associate the volume access group with.</span>
<span class="sd">        :type virtual_network_tags: int[]</span>

<span class="sd">        :param name: (optional) Name of the volume access group. It is not</span>
<span class="sd">            required to be unique, but recommended.</span>
<span class="sd">        :type name: str</span>

<span class="sd">        :param initiators: (optional) List of initiators to include in the</span>
<span class="sd">            volume access group. If unspecified, the access group&#39;s configured</span>
<span class="sd">            initiators will not be modified.</span>
<span class="sd">        :type initiators: str[]</span>

<span class="sd">        :param volumes: (optional) List of volumes to initially include in the</span>
<span class="sd">            volume access group. If unspecified, the access group&#39;s volumes</span>
<span class="sd">            will not be modified.</span>
<span class="sd">        :type volumes: int[]</span>

<span class="sd">        :param attributes: (optional) List of Name/Value pairs in JSON object</span>
<span class="sd">            format.</span>
<span class="sd">        :type attributes: dict</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_param_versions</span><span class="p">(</span>
            <span class="s1">&#39;modify_volume_access_group&#39;</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="s2">&quot;virtual_network_id&quot;</span><span class="p">,</span>
                 <span class="n">virtual_network_id</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">(</span><span class="s2">&quot;virtual_network_tags&quot;</span><span class="p">,</span>
                 <span class="n">virtual_network_tags</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">virtual_network_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkID&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_id</span>
        <span class="k">if</span> <span class="n">virtual_network_tags</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;virtualNetworkTags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">virtual_network_tags</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="n">initiators</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;initiators&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">initiators</span>
        <span class="k">if</span> <span class="n">volumes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;volumes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">volumes</span>
        <span class="k">if</span> <span class="n">attributes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;attributes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">attributes</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_initiators_to_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_initiators_to_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">add_initiators_to_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">initiators</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add initiators to a volume access group.</span>

<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to modify.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param initiators: [required] List of initiators to add to the volume</span>
<span class="sd">            access group.</span>
<span class="sd">        :type initiators: str[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="s2">&quot;initiators&quot;</span><span class="p">:</span> <span class="n">initiators</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddInitiatorsToVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_initiators_from_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_initiators_from_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">remove_initiators_from_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">initiators</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove initiators from a volume access group.</span>

<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to modify.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param initiators: [required] List of initiators to remove from the</span>
<span class="sd">            volume access group.</span>
<span class="sd">        :type initiators: str[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="s2">&quot;initiators&quot;</span><span class="p">:</span> <span class="n">initiators</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveInitiatorsFromVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.add_volumes_to_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.add_volumes_to_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">add_volumes_to_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">volumes</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add volumes to a volume access group.</span>

<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to modify.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param volumes: [required] List of volumes to add to this volume access</span>
<span class="sd">            group.</span>
<span class="sd">        :type volumes: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="s2">&quot;volumes&quot;</span><span class="p">:</span> <span class="n">volumes</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;AddVolumesToVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.remove_volumes_from_volume_access_group"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.remove_volumes_from_volume_access_group">[docs]</a>    <span class="k">def</span> <span class="nf">remove_volumes_from_volume_access_group</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">volumes</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove volumes from a volume access group.</span>

<span class="sd">        :param volume_access_group_id: [required] The ID of the volume access</span>
<span class="sd">            group to modify.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param volumes: [required] List of volumes to remove from this volume</span>
<span class="sd">            access group.</span>
<span class="sd">        :type volumes: int[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="s2">&quot;volumes&quot;</span><span class="p">:</span> <span class="n">volumes</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;RemoveVolumesFromVolumeAccessGroup&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_volume_access_group_efficiency"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_volume_access_group_efficiency">[docs]</a>    <span class="k">def</span> <span class="nf">get_volume_access_group_efficiency</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *get_volume_access_group_efficiency* is used to retrieve efficiency</span>
<span class="sd">        information about a volume access group. Only the volume access group</span>
<span class="sd">        provided as parameters in this API method is used to compute the</span>
<span class="sd">        capacity.</span>

<span class="sd">        :param volume_access_group_id: [required] Specifies the volume access</span>
<span class="sd">            group for which capacity is computed.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetEfficiencyResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetVolumeAccessGroupEfficiency&#39;</span><span class="p">,</span>
            <span class="n">GetEfficiencyResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.get_volume_access_group_lun_assignments"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.get_volume_access_group_lun_assignments">[docs]</a>    <span class="k">def</span> <span class="nf">get_volume_access_group_lun_assignments</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *get_volume_access_group_lun_assignments* is used to return</span>
<span class="sd">        information LUN mappings of a specified volume access group.</span>

<span class="sd">        :param volume_access_group_id: [required] Unique volume access group ID</span>
<span class="sd">            used to return information.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: GetVolumeAccessGroupLunAssignmentsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;GetVolumeAccessGroupLunAssignments&#39;</span><span class="p">,</span>
            <span class="n">GetVolumeAccessGroupLunAssignmentsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Element.modify_volume_access_group_lun_assignments"><a class="viewcode-back" href="../solidfire.html#solidfire.Element.modify_volume_access_group_lun_assignments">[docs]</a>    <span class="k">def</span> <span class="nf">modify_volume_access_group_lun_assignments</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="n">lun_assignments</span><span class="p">,):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The *modifyt_volume_access_group_lun_assignments* is used to define</span>
<span class="sd">        custom LUN assignments for specific volumes. Only LUN values set on the</span>
<span class="sd">        *lun_assignments* parameter will be changed in the volume access group.</span>
<span class="sd">        All other LUN assignments will remain unchanged.</span>




<span class="sd">        LUN assignment values must be unique for volumes in a volume access</span>
<span class="sd">        group. An exception will be seen if LUN assignments are duplicated in a</span>
<span class="sd">        volume access group. However, the same LUN values can be used again in</span>
<span class="sd">        different volume access groups.</span>




<span class="sd">        **Note:** Correct LUN values are 0 - 16383. An exception will be seen</span>
<span class="sd">        if an incorrect LUN value is passed. None of the specified LUN</span>
<span class="sd">        assignments will be modified if there is an exception.</span>




<span class="sd">        **Caution:** If a LUN assignment is changed for a volume with active</span>
<span class="sd">        I/O, the I/O could be disrupted. Changes to the server configuration</span>
<span class="sd">        may be required in order to change volume LUN assignments.</span>

<span class="sd">        :param volume_access_group_id: [required] Unique volume access group ID</span>
<span class="sd">            for which the LUN assignments will be modified.</span>
<span class="sd">        :type volume_access_group_id: int</span>

<span class="sd">        :param lun_assignments: [required] The volume *ids* with new assigned</span>
<span class="sd">            LUN values.</span>
<span class="sd">        :type lun_assignments: LunAssignment[]</span>

<span class="sd">        :returns: a response</span>
<span class="sd">        :rtype: ModifyVolumeAccessGroupLunAssignmentsResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;volumeAccessGroupID&quot;</span><span class="p">:</span> <span class="n">volume_access_group_id</span><span class="p">,</span>
            <span class="s2">&quot;lunAssignments&quot;</span><span class="p">:</span> <span class="n">lun_assignments</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">send_request</span><span class="p">(</span>
            <span class="s1">&#39;ModifyVolumeAccessGroupLunAssignments&#39;</span><span class="p">,</span>
            <span class="n">ModifyVolumeAccessGroupLunAssignmentsResult</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
        <span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014-2016, NetApp, Inc.  All Rights Reserved..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.1.0.85',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>